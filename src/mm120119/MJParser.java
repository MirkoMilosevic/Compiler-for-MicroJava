
//----------------------------------------------------
// The following code was generated by CUP v0.11a beta 20060608
// Tue Aug 29 23:19:57 CEST 2017
//----------------------------------------------------

package mm120119;

import java_cup.runtime.*;
import org.apache.log4j.*;
import rs.etf.pp1.symboltable.Tab;
import rs.etf.pp1.symboltable.concepts.*;
import rs.etf.pp1.mj.runtime.Code;
import java.util.*;

/** CUP v0.11a beta 20060608 generated parser.
  * @version Tue Aug 29 23:19:57 CEST 2017
  */
public class MJParser extends java_cup.runtime.lr_parser {

  /** Default constructor. */
  public MJParser() {super();}

  /** Constructor which sets the default scanner. */
  public MJParser(java_cup.runtime.Scanner s) {super(s);}

  /** Constructor which sets the default scanner. */
  public MJParser(java_cup.runtime.Scanner s, java_cup.runtime.SymbolFactory sf) {super(s,sf);}

  /** Production table. */
  protected static final short _production_table[][] = 
    unpackFromStrings(new String[] {
    "\000\231\000\002\064\012\000\002\002\004\000\002\065" +
    "\003\000\002\025\004\000\002\025\002\000\002\060\003" +
    "\000\002\060\003\000\002\060\003\000\002\105\002\000" +
    "\002\106\002\000\002\107\002\000\002\022\007\000\002" +
    "\023\005\000\002\023\003\000\002\057\005\000\002\057" +
    "\005\000\002\024\003\000\002\024\003\000\002\024\003" +
    "\000\002\077\005\000\002\077\005\000\002\110\002\000" +
    "\002\077\013\000\002\077\007\000\002\101\005\000\002" +
    "\101\003\000\002\061\004\000\002\061\006\000\002\014" +
    "\006\000\002\100\004\000\002\100\004\000\002\104\002" +
    "\000\002\011\013\000\002\013\003\000\002\036\004\000" +
    "\002\036\002\000\002\015\004\000\002\015\002\000\002" +
    "\012\005\000\002\012\002\000\002\102\002\000\002\103" +
    "\002\000\002\111\002\000\002\047\015\000\002\051\003" +
    "\000\002\067\003\000\002\067\003\000\002\050\004\000" +
    "\002\050\002\000\002\052\004\000\002\052\002\000\002" +
    "\071\004\000\002\071\002\000\002\072\003\000\002\072" +
    "\002\000\002\045\003\000\002\045\002\000\002\044\005" +
    "\000\002\044\003\000\002\043\004\000\002\043\006\000" +
    "\002\043\003\000\002\076\007\000\002\074\003\000\002" +
    "\070\003\000\002\070\003\000\002\075\007\000\002\075" +
    "\011\000\002\075\013\000\002\046\011\000\002\046\013" +
    "\000\002\046\004\000\002\046\004\000\002\046\004\000" +
    "\002\046\005\000\002\046\004\000\002\046\007\000\002" +
    "\046\010\000\002\046\005\000\002\042\003\000\002\042" +
    "\002\000\002\041\003\000\002\041\002\000\002\063\004" +
    "\000\002\063\002\000\002\112\002\000\002\030\006\000" +
    "\002\030\006\000\002\030\004\000\002\030\004\000\002" +
    "\030\005\000\002\031\003\000\002\031\002\000\002\002" +
    "\003\000\002\034\005\000\002\034\003\000\002\016\004" +
    "\000\002\062\005\000\002\062\002\000\002\021\004\000" +
    "\002\007\005\000\002\007\002\000\002\017\004\000\002" +
    "\020\004\000\002\020\002\000\002\033\004\000\002\035" +
    "\003\000\002\035\002\000\002\113\002\000\002\006\006" +
    "\000\002\006\003\000\002\073\004\000\002\054\005\000" +
    "\002\054\002\000\002\037\004\000\002\037\003\000\002" +
    "\037\003\000\002\037\003\000\002\037\003\000\002\037" +
    "\004\000\002\037\007\000\002\037\005\000\002\040\005" +
    "\000\002\114\002\000\002\026\005\000\002\032\005\000" +
    "\002\032\004\000\002\032\002\000\002\115\002\000\002" +
    "\027\006\000\002\010\003\000\002\010\003\000\002\010" +
    "\003\000\002\066\003\000\002\066\003\000\002\066\003" +
    "\000\002\066\003\000\002\066\003\000\002\066\003\000" +
    "\002\003\003\000\002\003\003\000\002\004\003\000\002" +
    "\004\003\000\002\005\003\000\002\005\003\000\002\053" +
    "\003\000\002\053\003\000\002\055\003\000\002\055\003" +
    "\000\002\055\003\000\002\056\003\000\002\056\003\000" +
    "\002\056\003" });

  /** Access to production table. */
  public short[][] production_table() {return _production_table;}

  /** Parse-action table. */
  protected static final short[][] _action_table = 
    unpackFromStrings(new String[] {
    "\000\367\000\004\054\005\001\002\000\004\002\371\001" +
    "\002\000\004\027\007\001\002\000\012\010\ufff9\012\ufff9" +
    "\027\ufff9\032\ufff9\001\002\000\012\010\uffff\012\uffff\027" +
    "\uffff\032\uffff\001\002\000\012\010\ufffd\012\ufffd\027\ufffd" +
    "\032\ufffd\001\002\000\012\010\021\012\022\027\013\032" +
    "\ufff8\001\002\000\006\003\346\027\061\001\002\000\070" +
    "\003\uffc2\004\uffc2\011\uffc2\015\uffc2\016\uffc2\017\uffc2\023" +
    "\uffc2\025\uffc2\026\uffc2\027\uffc2\032\uffc2\033\uffc2\034\uffc2" +
    "\036\uffc2\037\uffc2\040\uffc2\041\uffc2\042\uffc2\043\uffc2\044" +
    "\uffc2\046\uffc2\050\uffc2\051\uffc2\052\uffc2\060\uffc2\061\uffc2" +
    "\062\uffc2\001\002\000\012\010\ufffa\012\ufffa\027\ufffa\032" +
    "\ufffa\001\002\000\012\010\ufffb\012\ufffb\027\ufffb\032\ufffb" +
    "\001\002\000\012\010\ufffe\012\ufffe\027\ufffe\032\ufffe\001" +
    "\002\000\012\010\ufffc\012\ufffc\027\ufffc\032\ufffc\001\002" +
    "\000\004\032\343\001\002\000\004\027\042\001\002\000" +
    "\004\027\013\001\002\000\004\027\ufff7\001\002\000\004" +
    "\027\027\001\002\000\006\011\ufff4\062\ufff4\001\002\000" +
    "\006\011\036\062\037\001\002\000\004\022\030\001\002" +
    "\000\012\003\031\005\033\007\035\047\032\001\002\000" +
    "\006\011\ufff2\062\ufff2\001\002\000\006\011\uffef\062\uffef" +
    "\001\002\000\006\011\ufff0\062\ufff0\001\002\000\006\011" +
    "\ufff3\062\ufff3\001\002\000\006\011\ufff1\062\ufff1\001\002" +
    "\000\004\027\027\001\002\000\012\010\ufff6\012\ufff6\027" +
    "\ufff6\032\ufff6\001\002\000\006\011\ufff5\062\ufff5\001\002" +
    "\000\006\021\043\032\uffde\001\002\000\006\021\uffe0\032" +
    "\uffe0\001\002\000\004\027\013\001\002\000\004\032\uffd9" +
    "\001\002\000\004\032\046\001\002\000\012\027\uffdc\032" +
    "\uffdc\057\uffdc\063\uffdc\001\002\000\012\027\uffcb\032\051" +
    "\057\uffda\063\053\001\002\000\012\027\uffdd\032\uffdd\057" +
    "\uffdd\063\uffdd\001\002\000\012\027\uffd1\057\uffd1\063\uffd1" +
    "\064\uffd1\001\002\000\004\027\013\001\002\000\006\027" +
    "\uffcc\064\uffcc\001\002\000\004\057\uffd8\001\002\000\004" +
    "\057\056\001\002\000\012\010\uffe1\012\uffe1\027\uffe1\032" +
    "\uffe1\001\002\000\004\027\061\001\002\000\010\003\uffe8" +
    "\011\uffe8\062\uffe8\001\002\000\012\003\uffe2\011\uffe2\036" +
    "\066\062\uffe2\001\002\000\006\011\063\062\064\001\002" +
    "\000\004\027\061\001\002\000\012\027\uffe5\032\uffe5\057" +
    "\uffe5\063\uffe5\001\002\000\010\003\uffe9\011\uffe9\062\uffe9" +
    "\001\002\000\004\061\070\001\002\000\010\003\uffe7\011" +
    "\uffe7\062\uffe7\001\002\000\010\003\uffe2\011\uffe2\062\uffe2" +
    "\001\002\000\010\003\uffe6\011\uffe6\062\uffe6\001\002\000" +
    "\012\027\uffcb\057\075\063\053\064\uffcb\001\002\000\006" +
    "\027\013\064\077\001\002\000\012\027\uffd2\057\uffd2\063" +
    "\uffd2\064\uffd2\001\002\000\004\057\uffdb\001\002\000\004" +
    "\027\uffd4\001\002\000\004\027\uffd3\001\002\000\004\027" +
    "\101\001\002\000\004\035\uffd5\001\002\000\004\035\103" +
    "\001\002\000\006\027\013\060\uffc9\001\002\000\006\011" +
    "\340\060\uffca\001\002\000\006\017\332\027\331\001\002" +
    "\000\004\060\111\001\002\000\006\011\uffc4\060\uffc4\001" +
    "\002\000\006\011\uffc7\060\uffc7\001\002\000\006\027\uffcf" +
    "\032\uffcf\001\002\000\006\027\013\032\113\001\002\000" +
    "\026\006\uffd7\013\uffd7\024\uffd7\027\uffd7\030\uffd7\032\uffd7" +
    "\053\uffd7\055\uffd7\056\uffd7\057\uffd7\001\002\000\006\027" +
    "\uffd0\032\uffd0\001\002\000\026\006\uffcd\013\uffcd\024\uffcd" +
    "\027\uffcd\030\uffcd\032\uffcd\053\uffcd\055\uffcd\056\uffcd\057" +
    "\uffcd\001\002\000\026\006\135\013\132\024\122\027\121" +
    "\030\125\032\120\053\130\055\117\056\133\057\134\001" +
    "\002\000\004\035\325\001\002\000\026\006\uffcd\013\uffcd" +
    "\024\uffcd\027\uffcd\030\uffcd\032\uffcd\053\uffcd\055\uffcd\056" +
    "\uffcd\057\uffcd\001\002\000\072\004\uff86\011\uff86\014\uff86" +
    "\015\uff86\016\uff86\017\uff86\022\uff86\023\uff86\025\uff86\026" +
    "\uff86\031\uff86\033\uff86\034\uff86\035\uff86\036\uff86\037\uff86" +
    "\040\uff86\041\uff86\042\uff86\043\uff86\044\uff86\046\uff86\050" +
    "\uff86\051\uff86\052\uff86\060\uff86\061\uff86\062\uff86\001\002" +
    "\000\004\035\277\001\002\000\026\006\uffc1\013\uffc1\024" +
    "\uffc1\027\uffc1\030\uffc1\032\uffc1\053\uffc1\055\uffc1\056\uffc1" +
    "\057\uffc1\001\002\000\024\014\266\016\160\022\265\031" +
    "\263\035\271\040\177\042\162\044\170\052\175\001\002" +
    "\000\004\035\231\001\002\000\004\062\230\001\002\000" +
    "\026\006\uffce\013\uffce\024\uffce\027\uffce\030\uffce\032\uffce" +
    "\053\uffce\055\uffce\056\uffce\057\uffce\001\002\000\004\035" +
    "\221\001\002\000\026\006\uffc0\013\uffc0\024\uffc0\027\uffc0" +
    "\030\uffc0\032\uffc0\053\uffc0\055\uffc0\056\uffc0\057\uffc0\001" +
    "\002\000\004\062\220\001\002\000\022\005\uff96\007\uff96" +
    "\027\uff96\035\uff96\037\142\045\uff96\047\uff96\062\141\001" +
    "\002\000\012\027\uffd6\057\uffd6\063\uffd6\064\uffd6\001\002" +
    "\000\004\062\136\001\002\000\030\006\uffb9\013\uffb9\020" +
    "\uffb9\024\uffb9\027\uffb9\030\uffb9\032\uffb9\053\uffb9\055\uffb9" +
    "\056\uffb9\057\uffb9\001\002\000\016\005\144\007\154\027" +
    "\121\035\153\045\145\047\147\001\002\000\004\062\143" +
    "\001\002\000\030\006\uffb6\013\uffb6\020\uffb6\024\uffb6\027" +
    "\uffb6\030\uffb6\032\uffb6\053\uffb6\055\uffb6\056\uffb6\057\uffb6" +
    "\001\002\000\016\005\uff97\007\uff97\027\uff97\035\uff97\045" +
    "\uff97\047\uff97\001\002\000\030\006\uffb7\013\uffb7\020\uffb7" +
    "\024\uffb7\027\uffb7\030\uffb7\032\uffb7\053\uffb7\055\uffb7\056" +
    "\uffb7\057\uffb7\001\002\000\056\004\uff8b\011\uff8b\015\uff8b" +
    "\016\uff8b\023\uff8b\025\uff8b\026\uff8b\033\uff8b\034\uff8b\037" +
    "\uff8b\040\uff8b\041\uff8b\042\uff8b\043\uff8b\044\uff8b\046\uff8b" +
    "\050\uff8b\051\uff8b\052\uff8b\060\uff8b\061\uff8b\062\uff8b\001" +
    "\002\000\004\027\013\001\002\000\060\004\uff8e\011\uff8e" +
    "\015\uff8e\016\uff8e\023\uff8e\025\uff8e\026\uff8e\033\uff8e\034" +
    "\uff8e\035\204\037\uff8e\040\uff8e\041\uff8e\042\uff8e\043\uff8e" +
    "\044\uff8e\046\uff8e\050\uff8e\051\uff8e\052\uff8e\060\uff8e\061" +
    "\uff8e\062\uff8e\001\002\000\056\004\uff8d\011\uff8d\015\uff8d" +
    "\016\uff8d\023\uff8d\025\uff8d\026\uff8d\033\uff8d\034\uff8d\037" +
    "\uff8d\040\uff8d\041\uff8d\042\uff8d\043\uff8d\044\uff8d\046\uff8d" +
    "\050\uff8d\051\uff8d\052\uff8d\060\uff8d\061\uff8d\062\uff8d\001" +
    "\002\000\042\004\uff98\011\uff98\023\uff98\025\uff98\026\uff98" +
    "\033\uff98\034\uff98\037\200\040\177\046\uff98\050\uff98\051" +
    "\176\052\175\060\uff98\061\uff98\062\uff98\001\002\000\042" +
    "\004\uff93\011\uff93\023\uff93\025\uff93\026\uff93\033\uff93\034" +
    "\uff93\037\uff93\040\uff93\046\uff93\050\uff93\051\uff93\052\uff93" +
    "\060\uff93\061\uff93\062\uff93\001\002\000\056\004\uff90\011" +
    "\uff90\015\uff90\016\uff90\023\uff90\025\uff90\026\uff90\033\uff90" +
    "\034\uff90\037\uff90\040\uff90\041\uff90\042\uff90\043\uff90\044" +
    "\uff90\046\uff90\050\uff90\051\uff90\052\uff90\060\uff90\061\uff90" +
    "\062\uff90\001\002\000\020\005\uff96\007\uff96\027\uff96\035" +
    "\uff96\037\142\045\uff96\047\uff96\001\002\000\056\004\uff8c" +
    "\011\uff8c\015\uff8c\016\uff8c\023\uff8c\025\uff8c\026\uff8c\033" +
    "\uff8c\034\uff8c\037\uff8c\040\uff8c\041\uff8c\042\uff8c\043\uff8c" +
    "\044\uff8c\046\uff8c\050\uff8c\051\uff8c\052\uff8c\060\uff8c\061" +
    "\uff8c\062\uff8c\001\002\000\004\060\156\001\002\000\056" +
    "\004\uff88\011\uff88\015\uff88\016\uff88\023\uff88\025\uff88\026" +
    "\uff88\033\uff88\034\uff88\037\uff88\040\uff88\041\uff88\042\uff88" +
    "\043\uff88\044\uff88\046\uff88\050\uff88\051\uff88\052\uff88\060" +
    "\uff88\061\uff88\062\uff88\001\002\000\056\004\uff92\011\uff92" +
    "\015\165\016\160\023\uff92\025\uff92\026\uff92\033\uff92\034" +
    "\uff92\037\uff92\040\uff92\041\161\042\162\043\167\044\170" +
    "\046\uff92\050\uff92\051\uff92\052\uff92\060\uff92\061\uff92\062" +
    "\uff92\001\002\000\020\005\uff6a\007\uff6a\027\uff6a\035\uff6a" +
    "\037\uff6a\045\uff6a\047\uff6a\001\002\000\016\005\uff6c\007" +
    "\uff6c\027\uff6c\035\uff6c\045\uff6c\047\uff6c\001\002\000\020" +
    "\005\uff69\007\uff69\027\uff69\035\uff69\037\uff69\045\uff69\047" +
    "\uff69\001\002\000\016\005\144\007\154\027\121\035\153" +
    "\045\145\047\147\001\002\000\016\005\uff70\007\uff70\027" +
    "\uff70\035\uff70\045\uff70\047\uff70\001\002\000\016\005\uff6d" +
    "\007\uff6d\027\uff6d\035\uff6d\045\uff6d\047\uff6d\001\002\000" +
    "\016\005\uff6f\007\uff6f\027\uff6f\035\uff6f\045\uff6f\047\uff6f" +
    "\001\002\000\016\005\uff6e\007\uff6e\027\uff6e\035\uff6e\045" +
    "\uff6e\047\uff6e\001\002\000\020\005\uff6b\007\uff6b\027\uff6b" +
    "\035\uff6b\037\uff6b\045\uff6b\047\uff6b\001\002\000\056\004" +
    "\uff91\011\uff91\015\uff91\016\uff91\023\uff91\025\uff91\026\uff91" +
    "\033\uff91\034\uff91\037\uff91\040\uff91\041\uff91\042\uff91\043" +
    "\uff91\044\uff91\046\uff91\050\uff91\051\uff91\052\uff91\060\uff91" +
    "\061\uff91\062\uff91\001\002\000\016\005\uff76\007\uff76\027" +
    "\uff76\035\uff76\045\uff76\047\uff76\001\002\000\016\005\uff75" +
    "\007\uff75\027\uff75\035\uff75\045\uff75\047\uff75\001\002\000" +
    "\016\005\uff95\007\uff95\027\uff95\035\uff95\045\uff95\047\uff95" +
    "\001\002\000\020\005\uff72\007\uff72\027\uff72\035\uff72\037" +
    "\uff72\045\uff72\047\uff72\001\002\000\016\005\uff74\007\uff74" +
    "\027\uff74\035\uff74\045\uff74\047\uff74\001\002\000\020\005" +
    "\uff71\007\uff71\027\uff71\035\uff71\037\uff71\045\uff71\047\uff71" +
    "\001\002\000\016\005\uff73\007\uff73\027\uff73\035\uff73\045" +
    "\uff73\047\uff73\001\002\000\016\005\144\007\154\027\121" +
    "\035\153\045\145\047\147\001\002\000\042\004\uff94\011" +
    "\uff94\023\uff94\025\uff94\026\uff94\033\uff94\034\uff94\037\uff94" +
    "\040\uff94\046\uff94\050\uff94\051\uff94\052\uff94\060\uff94\061" +
    "\uff94\062\uff94\001\002\000\056\004\uff8f\011\uff8f\015\uff8f" +
    "\016\uff8f\023\uff8f\025\uff8f\026\uff8f\033\uff8f\034\uff8f\037" +
    "\uff8f\040\uff8f\041\uff8f\042\uff8f\043\uff8f\044\uff8f\046\uff8f" +
    "\050\uff8f\051\uff8f\052\uff8f\060\uff8f\061\uff8f\062\uff8f\001" +
    "\002\000\022\005\uff96\007\uff96\027\uff96\035\uff96\037\142" +
    "\045\uff96\047\uff96\060\uffa5\001\002\000\006\011\uffa2\060" +
    "\uffa2\001\002\000\004\060\uffa6\001\002\000\006\011\212" +
    "\060\uffa4\001\002\000\004\060\211\001\002\000\056\004" +
    "\uff87\011\uff87\015\uff87\016\uff87\023\uff87\025\uff87\026\uff87" +
    "\033\uff87\034\uff87\037\uff87\040\uff87\041\uff87\042\uff87\043" +
    "\uff87\044\uff87\046\uff87\050\uff87\051\uff87\052\uff87\060\uff87" +
    "\061\uff87\062\uff87\001\002\000\020\005\uff96\007\uff96\027" +
    "\uff96\035\uff96\037\142\045\uff96\047\uff96\001\002\000\006" +
    "\011\uffa3\060\uffa3\001\002\000\060\004\uff8a\011\uff8a\015" +
    "\uff8a\016\uff8a\023\uff8a\025\uff8a\026\uff8a\033\uff8a\034\uff8a" +
    "\036\215\037\uff8a\040\uff8a\041\uff8a\042\uff8a\043\uff8a\044" +
    "\uff8a\046\uff8a\050\uff8a\051\uff8a\052\uff8a\060\uff8a\061\uff8a" +
    "\062\uff8a\001\002\000\020\005\uff96\007\uff96\027\uff96\035" +
    "\uff96\037\142\045\uff96\047\uff96\001\002\000\004\061\217" +
    "\001\002\000\056\004\uff89\011\uff89\015\uff89\016\uff89\023" +
    "\uff89\025\uff89\026\uff89\033\uff89\034\uff89\037\uff89\040\uff89" +
    "\041\uff89\042\uff89\043\uff89\044\uff89\046\uff89\050\uff89\051" +
    "\uff89\052\uff89\060\uff89\061\uff89\062\uff89\001\002\000\030" +
    "\006\uffb8\013\uffb8\020\uffb8\024\uffb8\027\uffb8\030\uffb8\032" +
    "\uffb8\053\uffb8\055\uffb8\056\uffb8\057\uffb8\001\002\000\020" +
    "\005\uff96\007\uff96\027\uff96\035\uff96\037\142\045\uff96\047" +
    "\uff96\001\002\000\006\011\223\060\uffad\001\002\000\004" +
    "\047\227\001\002\000\004\060\225\001\002\000\004\062" +
    "\226\001\002\000\030\006\uffb4\013\uffb4\020\uffb4\024\uffb4" +
    "\027\uffb4\030\uffb4\032\uffb4\053\uffb4\055\uffb4\056\uffb4\057" +
    "\uffb4\001\002\000\004\060\uffae\001\002\000\030\006\uffba" +
    "\013\uffba\020\uffba\024\uffba\027\uffba\030\uffba\032\uffba\053" +
    "\uffba\055\uffba\056\uffba\057\uffba\001\002\000\020\005\uff96" +
    "\007\uff96\027\uff96\035\uff96\037\142\045\uff96\047\uff96\001" +
    "\002\000\010\050\uff9f\060\uff9f\062\uff9f\001\002\000\026" +
    "\004\uff99\023\254\025\252\026\253\033\256\034\251\046" +
    "\255\050\uff99\060\uff99\062\uff99\001\002\000\004\060\241" +
    "\001\002\000\012\004\uff9c\050\uff9c\060\uff9c\062\uff9c\001" +
    "\002\000\012\004\237\050\uff9e\060\uff9e\062\uff9e\001\002" +
    "\000\020\005\uff96\007\uff96\027\uff96\035\uff96\037\142\045" +
    "\uff96\047\uff96\001\002\000\012\004\uff9d\050\uff9d\060\uff9d" +
    "\062\uff9d\001\002\000\024\006\135\013\132\024\122\027" +
    "\121\030\125\032\120\053\130\055\117\056\133\001\002" +
    "\000\026\006\uffbf\013\uffbf\024\uffbf\027\uffbf\030\uffbf\032" +
    "\uffbf\053\uffbf\055\uffbf\056\uffbf\057\uffbf\001\002\000\030" +
    "\006\uffc0\013\uffc0\020\244\024\uffc0\027\uffc0\030\uffc0\032" +
    "\uffc0\053\uffc0\055\uffc0\056\uffc0\057\uffc0\001\002\000\024" +
    "\006\135\013\132\024\122\027\121\030\125\032\120\053" +
    "\130\055\117\056\133\001\002\000\026\006\uffbe\013\uffbe" +
    "\024\uffbe\027\uffbe\030\uffbe\032\uffbe\053\uffbe\055\uffbe\056" +
    "\uffbe\057\uffbe\001\002\000\030\006\uffbc\013\uffbc\020\uffbc" +
    "\024\uffbc\027\uffbc\030\uffbc\032\uffbc\053\uffbc\055\uffbc\056" +
    "\uffbc\057\uffbc\001\002\000\012\004\uff9b\050\uff9b\060\uff9b" +
    "\062\uff9b\001\002\000\020\005\uff96\007\uff96\027\uff96\035" +
    "\uff96\037\142\045\uff96\047\uff96\001\002\000\020\005\uff77" +
    "\007\uff77\027\uff77\035\uff77\037\uff77\045\uff77\047\uff77\001" +
    "\002\000\020\005\uff7a\007\uff7a\027\uff7a\035\uff7a\037\uff7a" +
    "\045\uff7a\047\uff7a\001\002\000\020\005\uff79\007\uff79\027" +
    "\uff79\035\uff79\037\uff79\045\uff79\047\uff79\001\002\000\020" +
    "\005\uff7c\007\uff7c\027\uff7c\035\uff7c\037\uff7c\045\uff7c\047" +
    "\uff7c\001\002\000\020\005\uff7b\007\uff7b\027\uff7b\035\uff7b" +
    "\037\uff7b\045\uff7b\047\uff7b\001\002\000\020\005\uff78\007" +
    "\uff78\027\uff78\035\uff78\037\uff78\045\uff78\047\uff78\001\002" +
    "\000\012\004\uff9a\050\uff9a\060\uff9a\062\uff9a\001\002\000" +
    "\010\050\261\060\uffa1\062\uffa1\001\002\000\020\005\uff96" +
    "\007\uff96\027\uff96\035\uff96\037\142\045\uff96\047\uff96\001" +
    "\002\000\010\050\uffa0\060\uffa0\062\uffa0\001\002\000\006" +
    "\060\uffa9\062\uffa9\001\002\000\020\005\uff7e\007\uff7e\027" +
    "\uff7e\035\uff7e\037\uff7e\045\uff7e\047\uff7e\001\002\000\022" +
    "\003\276\005\uff7f\007\uff7f\027\uff7f\035\uff7f\037\uff7f\045" +
    "\uff7f\047\uff7f\001\002\000\006\060\uffa8\062\uffa8\001\002" +
    "\000\020\005\uffac\007\uffac\027\uffac\035\uffac\037\uffac\045" +
    "\uffac\047\uffac\001\002\000\020\005\uff7d\007\uff7d\027\uff7d" +
    "\035\uff7d\037\uff7d\045\uff7d\047\uff7d\001\002\000\022\005" +
    "\uff96\007\uff96\027\uff96\035\uff96\037\142\045\uff96\047\uff96" +
    "\060\uffa5\001\002\000\004\060\273\001\002\000\006\060" +
    "\uffaa\062\uffaa\001\002\000\020\005\uff96\007\uff96\027\uff96" +
    "\035\uff96\037\142\045\uff96\047\uff96\001\002\000\006\060" +
    "\uffab\062\uffab\001\002\000\006\060\uffa7\062\uffa7\001\002" +
    "\000\006\027\121\062\uffb1\001\002\000\006\060\uffb2\062" +
    "\uffb2\001\002\000\004\062\302\001\002\000\022\005\uff96" +
    "\007\uff96\027\uff96\035\uff96\037\142\045\uff96\047\uff96\062" +
    "\uffaf\001\002\000\004\062\305\001\002\000\004\062\uffb0" +
    "\001\002\000\006\027\121\060\uffb1\001\002\000\004\060" +
    "\307\001\002\000\024\006\135\013\132\024\122\027\121" +
    "\030\125\032\120\053\130\055\117\056\133\001\002\000" +
    "\026\006\uffbd\013\uffbd\024\uffbd\027\uffbd\030\uffbd\032\uffbd" +
    "\053\uffbd\055\uffbd\056\uffbd\057\uffbd\001\002\000\030\006" +
    "\uffbb\013\uffbb\020\uffbb\024\uffbb\027\uffbb\030\uffbb\032\uffbb" +
    "\053\uffbb\055\uffbb\056\uffbb\057\uffbb\001\002\000\072\004" +
    "\uff82\011\uff82\014\uff82\015\uff82\016\uff82\017\uff82\022\uff82" +
    "\023\uff82\025\uff82\026\uff82\031\uff82\033\uff82\034\uff82\035" +
    "\uff82\036\uff82\037\uff82\040\uff82\041\uff82\042\uff82\043\uff82" +
    "\044\uff82\046\uff82\050\uff82\051\uff82\052\uff82\060\uff82\061" +
    "\uff82\062\uff82\001\002\000\072\004\uff85\011\uff85\014\uff85" +
    "\015\uff85\016\uff85\017\315\022\uff85\023\uff85\025\uff85\026" +
    "\uff85\031\uff85\033\uff85\034\uff85\035\uff85\036\314\037\uff85" +
    "\040\uff85\041\uff85\042\uff85\043\uff85\044\uff85\046\uff85\050" +
    "\uff85\051\uff85\052\uff85\060\uff85\061\uff85\062\uff85\001\002" +
    "\000\020\005\uff81\007\uff81\027\uff81\035\uff81\037\uff81\045" +
    "\uff81\047\uff81\001\002\000\004\027\317\001\002\000\072" +
    "\004\uff83\011\uff83\014\uff83\015\uff83\016\uff83\017\uff83\022" +
    "\uff83\023\uff83\025\uff83\026\uff83\031\uff83\033\uff83\034\uff83" +
    "\035\uff83\036\uff83\037\uff83\040\uff83\041\uff83\042\uff83\043" +
    "\uff83\044\uff83\046\uff83\050\uff83\051\uff83\052\uff83\060\uff83" +
    "\061\uff83\062\uff83\001\002\000\072\004\uff84\011\uff84\014" +
    "\uff84\015\uff84\016\uff84\017\uff84\022\uff84\023\uff84\025\uff84" +
    "\026\uff84\031\uff84\033\uff84\034\uff84\035\uff84\036\uff84\037" +
    "\uff84\040\uff84\041\uff84\042\uff84\043\uff84\044\uff84\046\uff84" +
    "\050\uff84\051\uff84\052\uff84\060\uff84\061\uff84\062\uff84\001" +
    "\002\000\020\005\uff96\007\uff96\027\uff96\035\uff96\037\142" +
    "\045\uff96\047\uff96\001\002\000\004\061\322\001\002\000" +
    "\072\004\uff80\011\uff80\014\uff80\015\uff80\016\uff80\017\uff80" +
    "\022\uff80\023\uff80\025\uff80\026\uff80\031\uff80\033\uff80\034" +
    "\uff80\035\uff80\036\uff80\037\uff80\040\uff80\041\uff80\042\uff80" +
    "\043\uff80\044\uff80\046\uff80\050\uff80\051\uff80\052\uff80\060" +
    "\uff80\061\uff80\062\uff80\001\002\000\026\006\135\013\132" +
    "\024\122\027\121\030\125\032\120\053\130\055\117\056" +
    "\133\057\324\001\002\000\030\006\uffb3\013\uffb3\020\uffb3" +
    "\024\uffb3\027\uffb3\030\uffb3\032\uffb3\053\uffb3\055\uffb3\056" +
    "\uffb3\057\uffb3\001\002\000\004\027\121\001\002\000\004" +
    "\060\327\001\002\000\004\062\330\001\002\000\030\006" +
    "\uffb5\013\uffb5\020\uffb5\024\uffb5\027\uffb5\030\uffb5\032\uffb5" +
    "\053\uffb5\055\uffb5\056\uffb5\057\uffb5\001\002\000\010\011" +
    "\uffc6\036\336\060\uffc6\001\002\000\004\017\333\001\002" +
    "\000\004\017\334\001\002\000\004\027\335\001\002\000" +
    "\006\011\uffc3\060\uffc3\001\002\000\004\061\337\001\002" +
    "\000\006\011\uffc5\060\uffc5\001\002\000\004\027\013\001" +
    "\002\000\006\011\uffc8\060\uffc8\001\002\000\004\032\uffdf" +
    "\001\002\000\012\027\uffd1\057\uffd1\063\uffd1\064\uffd1\001" +
    "\002\000\012\027\uffcb\057\345\063\053\064\uffcb\001\002" +
    "\000\004\002\001\001\002\000\004\062\370\001\002\000" +
    "\010\003\351\011\350\062\352\001\002\000\006\003\367" +
    "\027\061\001\002\000\006\011\356\062\357\001\002\000" +
    "\012\010\uffee\012\uffee\027\uffee\032\uffee\001\002\000\004" +
    "\027\061\001\002\000\006\011\063\062\355\001\002\000" +
    "\012\010\uffea\012\uffea\027\uffea\032\uffea\001\002\000\004" +
    "\027\uffe4\001\002\000\004\027\uffec\001\002\000\004\027" +
    "\013\001\002\000\006\003\363\011\362\001\002\000\004" +
    "\003\367\001\002\000\004\011\356\001\002\000\004\027" +
    "\061\001\002\000\006\011\063\062\366\001\002\000\012" +
    "\010\uffeb\012\uffeb\027\uffeb\032\uffeb\001\002\000\004\027" +
    "\uffe3\001\002\000\012\010\uffed\012\uffed\027\uffed\032\uffed" +
    "\001\002\000\004\002\000\001\002" });

  /** Access to parse-action table. */
  public short[][] action_table() {return _action_table;}

  /** <code>reduce_goto</code> table. */
  protected static final short[][] _reduce_table = 
    unpackFromStrings(new String[] {
    "\000\367\000\004\064\003\001\001\000\002\001\001\000" +
    "\004\065\005\001\001\000\004\105\007\001\001\000\002" +
    "\001\001\000\004\025\010\001\001\000\016\011\013\022" +
    "\016\060\015\074\011\077\014\106\017\001\001\000\006" +
    "\061\057\101\346\001\001\000\002\001\001\000\002\001" +
    "\001\000\002\001\001\000\002\001\001\000\002\001\001" +
    "\000\002\001\001\000\004\013\040\001\001\000\004\074" +
    "\022\001\001\000\004\107\023\001\001\000\006\023\025" +
    "\057\024\001\001\000\002\001\001\000\002\001\001\000" +
    "\002\001\001\000\004\024\033\001\001\000\002\001\001" +
    "\000\002\001\001\000\002\001\001\000\002\001\001\000" +
    "\002\001\001\000\004\057\037\001\001\000\002\001\001" +
    "\000\002\001\001\000\004\036\043\001\001\000\002\001" +
    "\001\000\004\074\341\001\001\000\004\102\044\001\001" +
    "\000\002\001\001\000\004\015\046\001\001\000\010\012" +
    "\053\014\047\072\051\001\001\000\002\001\001\000\004" +
    "\050\071\001\001\000\004\074\056\001\001\000\002\001" +
    "\001\000\004\103\054\001\001\000\002\001\001\000\002" +
    "\001\001\000\006\061\057\101\061\001\001\000\002\001" +
    "\001\000\004\104\066\001\001\000\002\001\001\000\004" +
    "\061\064\001\001\000\002\001\001\000\002\001\001\000" +
    "\002\001\001\000\002\001\001\000\004\104\070\001\001" +
    "\000\002\001\001\000\006\047\073\072\072\001\001\000" +
    "\006\067\077\074\075\001\001\000\002\001\001\000\002" +
    "\001\001\000\002\001\001\000\002\001\001\000\004\051" +
    "\101\001\001\000\002\001\001\000\002\001\001\000\014" +
    "\043\107\044\103\045\105\074\104\076\106\001\001\000" +
    "\002\001\001\000\002\001\001\000\002\001\001\000\002" +
    "\001\001\000\002\001\001\000\004\052\111\001\001\000" +
    "\006\074\011\077\113\001\001\000\004\111\114\001\001" +
    "\000\002\001\001\000\004\071\115\001\001\000\014\026" +
    "\123\030\125\046\130\070\126\075\122\001\001\000\002" +
    "\001\001\000\004\071\322\001\001\000\004\114\311\001" +
    "\001\000\002\001\001\000\002\001\001\000\010\005\263" +
    "\010\266\056\267\001\001\000\002\001\001\000\002\001" +
    "\001\000\002\001\001\000\002\001\001\000\002\001\001" +
    "\000\002\001\001\000\006\033\137\035\136\001\001\000" +
    "\002\001\001\000\002\001\001\000\002\001\001\000\012" +
    "\006\147\026\145\037\151\073\150\001\001\000\002\001" +
    "\001\000\002\001\001\000\002\001\001\000\002\001\001" +
    "\000\002\001\001\000\004\074\213\001\001\000\004\040" +
    "\202\001\001\000\002\001\001\000\010\003\173\004\171" +
    "\005\172\001\001\000\002\001\001\000\004\054\156\001" +
    "\001\000\006\033\154\035\136\001\001\000\002\001\001" +
    "\000\002\001\001\000\002\001\001\000\010\053\162\055" +
    "\163\056\165\001\001\000\002\001\001\000\002\001\001" +
    "\000\002\001\001\000\006\026\145\037\170\001\001\000" +
    "\002\001\001\000\002\001\001\000\002\001\001\000\002" +
    "\001\001\000\002\001\001\000\002\001\001\000\002\001" +
    "\001\000\002\001\001\000\004\113\200\001\001\000\002" +
    "\001\001\000\002\001\001\000\002\001\001\000\002\001" +
    "\001\000\010\026\145\037\151\073\201\001\001\000\002" +
    "\001\001\000\002\001\001\000\014\002\205\031\207\033" +
    "\204\034\206\035\136\001\001\000\002\001\001\000\002" +
    "\001\001\000\002\001\001\000\002\001\001\000\002\001" +
    "\001\000\006\033\212\035\136\001\001\000\002\001\001" +
    "\000\002\001\001\000\006\033\215\035\136\001\001\000" +
    "\002\001\001\000\002\001\001\000\002\001\001\000\006" +
    "\033\221\035\136\001\001\000\004\063\223\001\001\000" +
    "\002\001\001\000\002\001\001\000\002\001\001\000\002" +
    "\001\001\000\002\001\001\000\002\001\001\000\014\016" +
    "\233\017\234\021\231\033\232\035\136\001\001\000\004" +
    "\062\257\001\001\000\006\020\246\066\247\001\001\000" +
    "\002\001\001\000\004\007\235\001\001\000\002\001\001" +
    "\000\010\017\237\033\232\035\136\001\001\000\002\001" +
    "\001\000\014\026\123\030\125\046\242\070\241\075\122" +
    "\001\001\000\002\001\001\000\002\001\001\000\012\026" +
    "\123\030\125\046\245\075\244\001\001\000\002\001\001" +
    "\000\002\001\001\000\002\001\001\000\006\033\256\035" +
    "\136\001\001\000\002\001\001\000\002\001\001\000\002" +
    "\001\001\000\002\001\001\000\002\001\001\000\002\001" +
    "\001\000\002\001\001\000\002\001\001\000\012\017\234" +
    "\021\261\033\232\035\136\001\001\000\002\001\001\000" +
    "\002\001\001\000\002\001\001\000\002\001\001\000\002" +
    "\001\001\000\004\112\273\001\001\000\002\001\001\000" +
    "\014\002\205\031\271\033\204\034\206\035\136\001\001" +
    "\000\002\001\001\000\002\001\001\000\006\033\274\035" +
    "\136\001\001\000\002\001\001\000\002\001\001\000\010" +
    "\026\123\030\277\042\300\001\001\000\002\001\001\000" +
    "\002\001\001\000\016\016\303\017\234\021\231\033\232" +
    "\035\136\041\302\001\001\000\002\001\001\000\002\001" +
    "\001\000\010\026\123\030\277\042\305\001\001\000\002" +
    "\001\001\000\012\026\123\030\125\046\310\075\307\001" +
    "\001\000\002\001\001\000\002\001\001\000\004\032\312" +
    "\001\001\000\004\027\315\001\001\000\004\115\317\001" +
    "\001\000\002\001\001\000\002\001\001\000\002\001\001" +
    "\000\006\033\320\035\136\001\001\000\002\001\001\000" +
    "\002\001\001\000\014\026\123\030\125\046\130\070\126" +
    "\075\122\001\001\000\002\001\001\000\004\026\325\001" +
    "\001\000\002\001\001\000\002\001\001\000\002\001\001" +
    "\000\002\001\001\000\002\001\001\000\002\001\001\000" +
    "\002\001\001\000\002\001\001\000\002\001\001\000\002" +
    "\001\001\000\010\043\340\074\104\076\106\001\001\000" +
    "\002\001\001\000\002\001\001\000\004\050\343\001\001" +
    "\000\006\047\073\072\072\001\001\000\002\001\001\000" +
    "\002\001\001\000\004\100\352\001\001\000\004\061\064" +
    "\001\001\000\002\001\001\000\002\001\001\000\006\061" +
    "\057\101\353\001\001\000\002\001\001\000\002\001\001" +
    "\000\002\001\001\000\004\110\357\001\001\000\004\074" +
    "\360\001\001\000\004\100\363\001\001\000\002\001\001" +
    "\000\002\001\001\000\006\061\057\101\364\001\001\000" +
    "\002\001\001\000\002\001\001\000\002\001\001\000\002" +
    "\001\001\000\002\001\001" });

  /** Access to <code>reduce_goto</code> table. */
  public short[][] reduce_table() {return _reduce_table;}

  /** Instance of action encapsulation class. */
  protected CUP$MJParser$actions action_obj;

  /** Action encapsulation object initializer. */
  protected void init_actions()
    {
      action_obj = new CUP$MJParser$actions(this);
    }

  /** Invoke a user supplied parse action. */
  public java_cup.runtime.Symbol do_action(
    int                        act_num,
    java_cup.runtime.lr_parser parser,
    java.util.Stack            stack,
    int                        top)
    throws java.lang.Exception
  {
    /* call code in generated class */
    return action_obj.CUP$MJParser$do_action(act_num, parser, stack, top);
  }

  /** Indicates start state. */
  public int start_state() {return 0;}
  /** Indicates start production. */
  public int start_production() {return 1;}

  /** <code>EOF</code> Symbol index. */
  public int EOF_sym() {return 0;}

  /** <code>error</code> Symbol index. */
  public int error_sym() {return 1;}


  /** User initialization code. */
  public void user_init() throws java.lang.Exception
    {

	
	Tab.init(); // Universe scope
	Tab.currentScope.addToLocals(new Obj(Obj.Type, "bool", new Struct(Struct.Bool)));
	

    }

  /** Scan to get the next Symbol. */
  public java_cup.runtime.Symbol scan()
    throws java.lang.Exception
    {

	Symbol s = this.getScanner().next_token();
	if (s != null && s.value != null) 
		log.info(s.toString() + " " + s.value.toString());
	return s;

    }


	
	boolean errorDetected = false;
	
	// prebrojavanje simbola
	
	int countGlobalVar = 0;
	int countLocalVar = 0;
	int countGlobalConst = 0;
	
	boolean globalVarDecl = false;
	boolean inMain = false;
	boolean inClass = false;
	
	Logger log = Logger.getLogger(getClass());
   
   
    // slede redefinisani metodi za prijavu gresaka radi izmene teksta poruke
     
    public void report_fatal_error(String message, Object info) throws java.lang.Exception {
      done_parsing();
      report_error(message, info);
    }
  
    public void syntax_error(Symbol cur_token) {
        report_error("\nSintaksna greska", cur_token);
    }
  
    public void unrecovered_syntax_error(Symbol cur_token) throws java.lang.Exception {
        report_fatal_error("Fatalna greska, parsiranje se ne moze nastaviti", cur_token);
    }

    public void report_error(String message, Object info) {
    	errorDetected = true;
    	StringBuilder msg = new StringBuilder(message); 
    	if (info instanceof Symbol)
            msg.append (" na liniji ").append(((Symbol)info).left);
        log.error(msg.toString());
    }
    
     public void report_info(String message, Object info) {
    	StringBuilder msg = new StringBuilder(message); 
    	if (info instanceof Symbol)
            msg.append (" na liniji ").append(((Symbol)info).left);
        log.info(msg.toString());
    }
    

}

/** Cup generated class to encapsulate user supplied action code.*/
class CUP$MJParser$actions {


	
	//scope u kojem se nalaze globalne promenljive i konstante
	Scope topScope;
	
	//univers scope
	Scope universeScope;
	
	//da li sam u metodi
	boolean inMethod = false;
	
	//provera da li main postoji i da li je void
	boolean mainExists = false;
	boolean mainIsVoid = false;
	
	//za pamcenje do kog offseta se stiglo, stack - visak?
	int scopeOffset = 0;
	Stack stack = new Stack();
	
	//definisanje konstanti i provera da li su ispravnog tipa
	Struct currentConstType = Tab.noType;
	boolean correctConstType = false;
	
	//pamcenje tipa trenutne promenljive i metode (dovoljno jedna?) i koja vrednost treba da se vrati
	Struct currentVarType = Tab.noType;
	Struct currentMethType = Tab.noType;
	Struct currentMethodReturnType = Tab.noType;
	boolean methIsVoid = false;
	boolean staticExists = false;
	
	//metoda koja se deklarise
	Obj currentMethod = null;
	
	//da li metoda ima return iskaz
	boolean returnFound = false;
	
	//brojac za parametre i naziv varArgs
	int cntParam = 0;
	String varArgsName;
	boolean varArgsExists = false;
	int varArgsPosition = -1;
	
	//provera da li je kombinovani izraz
	boolean combArithOp = false;
	int combArithOpCnt = 0;
	int combArithOpArray[] = new int[25];
	Obj combArithOpDesignator[] = new Obj[25];
	Obj combArtihOpLast = null;
	
	//provera da li postoji minus
	boolean minusExists = false;
	
	//da li je designator clan niza
	boolean isArray = false;
	
	//za proveru parametara funkcije
	Obj niz[] = new Obj[25];
	int cnt = 0;
	
	//da li je specificirana sirina za print
	boolean isPrintNumConst = false;
	
	//da li se alocira novi niz;
	boolean newArray = false;
	Obj arrayAddress = null;
	int destInd = 0;
	
	//poruke za semanticku analizu
	String messages[] = new String[256];
	int messagesCnt = 0;

  private final MJParser parser;

  /** Constructor */
  CUP$MJParser$actions(MJParser parser) {
    this.parser = parser;
  }

  /** Method with the actual generated action code. */
  public final java_cup.runtime.Symbol CUP$MJParser$do_action(
    int                        CUP$MJParser$act_num,
    java_cup.runtime.lr_parser CUP$MJParser$parser,
    java.util.Stack            CUP$MJParser$stack,
    int                        CUP$MJParser$top)
    throws java.lang.Exception
    {
      /* Symbol object for return from actions */
      java_cup.runtime.Symbol CUP$MJParser$result;

      /* select the action based on the action number */
      switch (CUP$MJParser$act_num)
        {
          /*. . . . . . . . . . . . . . . . . . . .*/
          case 152: // MulOperationRight ::= MODEQUAL 
            {
              Integer RESULT =null;
		 
							combArithOp = true;
							combArithOpArray[combArithOpCnt] = Code.rem;
							combArithOpCnt++;
							RESULT = Code.rem;
					  
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("MulOperationRight",44, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 151: // MulOperationRight ::= DIVEQUAL 
            {
              Integer RESULT =null;
		 
							combArithOp = true;
							combArithOpArray[combArithOpCnt] = Code.div;
							combArithOpCnt++;
							RESULT = Code.div;
					  
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("MulOperationRight",44, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 150: // MulOperationRight ::= MULEQUAL 
            {
              Integer RESULT =null;
		 
							combArithOp = true;
							combArithOpArray[combArithOpCnt] = Code.mul;
							combArithOpCnt++;
							RESULT = Code.mul;
					  
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("MulOperationRight",44, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 149: // MulOperationLeft ::= MOD 
            {
              Integer RESULT =null;
		
						RESULT = Code.rem;
					 
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("MulOperationLeft",43, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 148: // MulOperationLeft ::= DIV 
            {
              Integer RESULT =null;
		
						RESULT = Code.div;
					 
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("MulOperationLeft",43, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 147: // MulOperationLeft ::= MUL 
            {
              Integer RESULT =null;
		
						RESULT = Code.mul;
					 
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("MulOperationLeft",43, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 146: // MulOperation ::= MulOperationRight 
            {
              Integer RESULT =null;
		int operationleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).left;
		int operationright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).right;
		Integer operation = (Integer)((java_cup.runtime.Symbol) CUP$MJParser$stack.peek()).value;
		
					 RESULT = operation;
				 
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("MulOperation",41, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 145: // MulOperation ::= MulOperationLeft 
            {
              Integer RESULT =null;
		int operationleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).left;
		int operationright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).right;
		Integer operation = (Integer)((java_cup.runtime.Symbol) CUP$MJParser$stack.peek()).value;
		
					 RESULT = operation;
				 
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("MulOperation",41, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 144: // AddOperationRight ::= MINUSEQUAL 
            {
              Integer RESULT =null;
		 
							combArithOp = true;
							combArithOpArray[combArithOpCnt] = Code.sub;
							combArithOpCnt++;
							RESULT = Code.sub;
					  
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("AddOperationRight",3, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 143: // AddOperationRight ::= PLUSEQUAL 
            {
              Integer RESULT =null;
		 
							combArithOp = true;
							combArithOpArray[combArithOpCnt] = Code.add;
							combArithOpCnt++;
							RESULT = Code.add;
					  
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("AddOperationRight",3, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 142: // AddOperationLeft ::= MINUS 
            {
              Integer RESULT =null;
		
						RESULT = Code.sub;
					 
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("AddOperationLeft",2, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 141: // AddOperationLeft ::= PLUS 
            {
              Integer RESULT =null;
		
						RESULT = Code.add;
					 
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("AddOperationLeft",2, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 140: // AddOperation ::= AddOperationRight 
            {
              Integer RESULT =null;
		int operationleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).left;
		int operationright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).right;
		Integer operation = (Integer)((java_cup.runtime.Symbol) CUP$MJParser$stack.peek()).value;
		
					 RESULT = operation;
				 
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("AddOperation",1, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 139: // AddOperation ::= AddOperationLeft 
            {
              Integer RESULT =null;
		int operationleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).left;
		int operationright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).right;
		Integer operation = (Integer)((java_cup.runtime.Symbol) CUP$MJParser$stack.peek()).value;
		
					 RESULT = operation;
				 
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("AddOperation",1, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 138: // RelationOperation ::= LESSEQUAL 
            {
              Object RESULT =null;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("RelationOperation",52, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 137: // RelationOperation ::= LESS 
            {
              Object RESULT =null;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("RelationOperation",52, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 136: // RelationOperation ::= GREQUAL 
            {
              Object RESULT =null;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("RelationOperation",52, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 135: // RelationOperation ::= GREATER 
            {
              Object RESULT =null;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("RelationOperation",52, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 134: // RelationOperation ::= NOTEQUAL 
            {
              Object RESULT =null;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("RelationOperation",52, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 133: // RelationOperation ::= EQUALEQUAL 
            {
              Object RESULT =null;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("RelationOperation",52, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 132: // AssignOperation ::= MulOperationRight 
            {
              Integer RESULT =null;
		int operationleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).left;
		int operationright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).right;
		Integer operation = (Integer)((java_cup.runtime.Symbol) CUP$MJParser$stack.peek()).value;
		 
						RESULT = operation; 
					
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("AssignOperation",6, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 131: // AssignOperation ::= AddOperationRight 
            {
              Integer RESULT =null;
		int operationleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).left;
		int operationright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).right;
		Integer operation = (Integer)((java_cup.runtime.Symbol) CUP$MJParser$stack.peek()).value;
		 
						RESULT = operation; 
					
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("AssignOperation",6, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 130: // AssignOperation ::= EQUAL 
            {
              Integer RESULT =null;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("AssignOperation",6, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 129: // DesignatorExpression ::= LSQUARE NT$6 Expression RSQUARE 
            {
              Obj RESULT =null;
              // propagate RESULT from NT$6
                RESULT = (Obj) ((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)).value;
		int eleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).left;
		int eright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).right;
		Obj e = (Obj)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).value;
		
							if(e.getType() != Tab.find("int").getType()) 
							{ 
								parser.report_error("Greska na liniji " + eleft + " izraz koji indeksira niz mora biti int!", null); 
								messages[messagesCnt++] = "Greska na liniji " + eleft + " izraz koji indeksira niz mora biti int!";
							}
							RESULT = e;
							isArray = true;
							destInd = e.getAdr();
						 
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("DesignatorExpression",21, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-3)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 128: // NT$6 ::= 
            {
              Obj RESULT =null;

							Code.load(arrayAddress);
						 
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("NT$6",75, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 127: // DesignatorTrailer ::= 
            {
              Obj RESULT =null;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("DesignatorTrailer",24, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 126: // DesignatorTrailer ::= DesignatorTrailer DesignatorExpression 
            {
              Obj RESULT =null;
		int deleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).left;
		int deright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).right;
		Obj de = (Obj)((java_cup.runtime.Symbol) CUP$MJParser$stack.peek()).value;
		 RESULT = de; 
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("DesignatorTrailer",24, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 125: // DesignatorTrailer ::= DesignatorTrailer DOT IDENT 
            {
              Obj RESULT =null;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("DesignatorTrailer",24, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 124: // Designator ::= IDENT NT$5 DesignatorTrailer 
            {
              Obj RESULT =null;
              // propagate RESULT from NT$5
                RESULT = (Obj) ((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).value;
		int nameleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)).left;
		int nameright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)).right;
		String name = (String)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)).value;
		int dtleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).left;
		int dtright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).right;
		Obj dt = (Obj)((java_cup.runtime.Symbol) CUP$MJParser$stack.peek()).value;
		
					if(dt != null)
					{
						Obj o = Tab.find(name);
						RESULT = new Obj(Obj.Elem, name, o.getType().getElemType());
						RESULT.setFpPos(dt.getAdr());
					}
					
				
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Designator",20, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 123: // NT$5 ::= 
            {
              Obj RESULT =null;
		int nameleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).left;
		int nameright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).right;
		String name = (String)((java_cup.runtime.Symbol) CUP$MJParser$stack.peek()).value;

					Obj o = null;
	
					if(inMethod)
					{
						o = Tab.currentScope().findSymbol(name);
		
						//pronasao lokalni simbol
						if((o != null) && (o.getAdr() > cntParam - 1))
						{ 
							parser.report_info("Koriscenje lokalne promenljive " + name +" na liniji " + nameleft, null);
							messages[messagesCnt++] = "Koriscenje lokalne promenljive " + name +" na liniji " + nameleft;
							RESULT = o;
						}
						else if (o != null)
						{ 
							parser.report_info("Koriscenje parametra " + name +" na liniji " + nameleft, null);
							messages[messagesCnt++] = "Koriscenje parametra " + name +" na liniji " + nameleft;
							RESULT = o; 
						}
						else
						{
							o = topScope.findSymbol(name);
			
							if(o != null)
							{
								if(o.getKind() == Obj.Con) 
								{ 
									parser.report_info("Koriscenje konstante " + name +" na liniji " + nameleft, null);
									messages[messagesCnt++] = "Koriscenje konstante " + name +" na liniji " + nameleft;
									RESULT = o;
								}
								if(o.getKind() == Obj.Var) 
								{ 
									parser.report_info("Koriscenje globalne promenljive " + name +" na liniji " + nameleft, null);
									messages[messagesCnt++] = "Koriscenje globalne promenljive " + name +" na liniji " + nameleft;
									RESULT = o;
								}
									if(o.getKind() == Obj.Meth)
								{ 
									parser.report_info("Poziv globalne funkcije " + name +" na liniji " + nameleft, null);
									messages[messagesCnt++] = "Poziv globalne funkcije " + name +" na liniji " + nameleft;
									RESULT = o; 
								}
							}
							else 
							{ 
								o = universeScope.findSymbol(name);
				
								if(o != null)
								{ 
									parser.report_info("Poziv funkcije iz universe opsega " + name +" na liniji " + nameleft, null); 
									messages[messagesCnt++] = "Poziv funkcije iz universe opsega " + name +" na liniji " + nameleft;
									RESULT = o;
								}
								else
								{ 
									parser.report_error("Greska na liniji" + nameleft+ ": Ime " + name + " ne postoji!", null); 
									messages[messagesCnt++] = "Greska na liniji" + nameleft+ ": Ime " + name + " ne postoji!";
									RESULT = o;
								} 
							}
						}
					}
					
					arrayAddress = o;
				
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("NT$5",74, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 122: // FactorActualParameters ::= LPAREN DesignatorStatementActualParameters RPAREN 
            {
              Object RESULT =null;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("FactorActualParameters",30, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 121: // Factor ::= LPAREN Expression RPAREN 
            {
              Obj RESULT =null;
		int eleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).left;
		int eright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).right;
		Obj e = (Obj)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).value;
		
				RESULT = e;
		   
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Factor",29, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 120: // Factor ::= NEW Type LSQUARE Expression RSQUARE 
            {
              Obj RESULT =null;
		int eleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).left;
		int eright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).right;
		Obj e = (Obj)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).value;
		
				if(e.getType() != Tab.find("int").getType()) 
				{ 
					parser.report_error("Greska na liniji " + eleft + " izraz u okviru new mora biti int!", null); 
					messages[messagesCnt++] = "Greska na liniji " + eleft + " izraz u okviru new mora biti int!";
				}
			
				newArray = true;
				int elemSize = 0;
				if(currentVarType == Tab.charType) 
				{ 
					elemSize = 0; 
					RESULT = Tab.find("char");
				}
				if(currentVarType == Tab.intType) 
				{ 
					elemSize = 1; 
					RESULT = Tab.find("int");
				}
				if(currentVarType == Tab.find("bool").getType())
				{
					elemSize = 1; 
					RESULT = Tab.find("bool");
				}
				
				Code.put(Code.newarray);
		   		Code.put(elemSize);
		   
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Factor",29, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-4)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 119: // Factor ::= NEW Type 
            {
              Obj RESULT =null;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Factor",29, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 118: // Factor ::= BOOL 
            {
              Obj RESULT =null;
		int valleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).left;
		int valright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).right;
		String val = (String)((java_cup.runtime.Symbol) CUP$MJParser$stack.peek()).value;
		 
		   		int vrednost;
		   		
		   		if(val.equals("true")) { vrednost = 1; }
			   	else { vrednost = 0; }
		   		
		   		Obj c = Tab.insert(Obj.Con, "", Tab.intType);
				c.setAdr(vrednost);
				Code.load(c);
		   		RESULT = Tab.find("bool"); 
		   
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Factor",29, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 117: // Factor ::= CHAR 
            {
              Obj RESULT =null;
		int valleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).left;
		int valright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).right;
		Character val = (Character)((java_cup.runtime.Symbol) CUP$MJParser$stack.peek()).value;
		 
				Obj c = Tab.insert(Obj.Con, "", Tab.charType);
				c.setAdr((int) val);
				Code.load(c);
				RESULT = Tab.find("char"); 
		   
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Factor",29, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 116: // Factor ::= NUMBER 
            {
              Obj RESULT =null;
		int valleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).left;
		int valright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).right;
		Integer val = (Integer)((java_cup.runtime.Symbol) CUP$MJParser$stack.peek()).value;
		 
				Obj c = Tab.insert(Obj.Con, "", Tab.intType);
				c.setAdr(val.intValue());
				Code.load(c); 
				RESULT = c;
		   
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Factor",29, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 115: // Factor ::= Designator 
            {
              Obj RESULT =null;
		int dleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).left;
		int dright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).right;
		Obj d = (Obj)((java_cup.runtime.Symbol) CUP$MJParser$stack.peek()).value;
		
				Code.load(d);
		   		RESULT = d;
		   
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Factor",29, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 114: // Factor ::= Designator FactorActualParameters 
            {
              Obj RESULT =null;
		int dleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).left;
		int dright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).right;
		Obj d = (Obj)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).value;
		 
		   		RESULT = d;
		   		if(d.getKind() != Obj.Meth)
		   		{ 
					parser.report_error("Greska na liniji " + dleft + " designator mora biti funkcija da bi mogao da se pozove!", null); 
					messages[messagesCnt++] = "Greska na liniji " + dleft + " designator mora biti funkcija da bi mogao da se pozove!";
				}

				if(d.getKind() != Obj.Meth)
				{ 
					parser.report_error("Greska na liniji " + dleft + " neterminal mora biti metoda!", null); 
					messages[messagesCnt++] = "Greska na liniji " + dleft + " neterminal mora biti metoda!";
				}
							
				int paramCnt = d.getLevel();
							
				if(paramCnt != cnt)
				{ 
					parser.report_error("Greska na liniji " + dleft + " poziv funkcije nema dovoljan broj parametara! Ima ih " + cnt + ", a treba da ih bude " + paramCnt + "!" , null); 
					messages[messagesCnt++] = "Greska na liniji " + dleft + " poziv funkcije nema dovoljan broj parametara! Ima ih " + cnt + ", a treba da ih bude " + paramCnt + "!";
				}
							
				int tek = 0;
							
				for(Obj param : d.getLocalSymbols()) 
				{	
					if(tek >= cnt) { break; }
					   			
					if(niz[tek++].getType().getKind() != param.getType().getKind()) 
					{ 
						parser.report_error("Greska na liniji " + dleft + " parametar na poziciji " + tek + " nije odgovarajuceg tipa!", null); 
						messages[messagesCnt++] = "Greska na liniji " + dleft + " parametar na poziciji " + tek + " nije odgovarajuceg tipa!";
					}
				}
							
				cnt = 0;
							
				int destAdr = d.getAdr() - Code.pc;
				Code.put(Code.call);
				Code.put2(destAdr);		
		   
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Factor",29, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 113: // MulOperationFactorList ::= 
            {
              Obj RESULT =null;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("MulOperationFactorList",42, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 112: // MulOperationFactorList ::= MulOperationFactorList MulOperation Factor 
            {
              Obj RESULT =null;
		int tip1left = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)).left;
		int tip1right = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)).right;
		Obj tip1 = (Obj)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)).value;
		int operationleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).left;
		int operationright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).right;
		Integer operation = (Integer)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).value;
		int tip2left = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).left;
		int tip2right = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).right;
		Obj tip2 = (Obj)((java_cup.runtime.Symbol) CUP$MJParser$stack.peek()).value;
		
								if(!combArithOp)
								{
									Code.put(operation);
								}
								else
								{
									combArithOpArray[combArithOpCnt-1] = operation;
									RESULT = tip2;
								}
						   
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("MulOperationFactorList",42, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 111: // Term ::= Factor MulOperationFactorList 
            {
              Obj RESULT =null;
		int tip1left = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).left;
		int tip1right = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).right;
		Obj tip1 = (Obj)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).value;
		int tip2left = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).left;
		int tip2right = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).right;
		Obj tip2 = (Obj)((java_cup.runtime.Symbol) CUP$MJParser$stack.peek()).value;
		
			if(tip2 != null)
			{ 
				if(combArithOp)
				{	
					combArithOpDesignator[combArithOpCnt-1] = tip1;
				}
		
			RESULT = tip2; 
			}
			else
			{ 
				RESULT = tip1;	
			}
		
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Term",57, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 110: // AddOperationTermList ::= Term 
            {
              Obj RESULT =null;
		int tleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).left;
		int tright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).right;
		Obj t = (Obj)((java_cup.runtime.Symbol) CUP$MJParser$stack.peek()).value;
		 RESULT = t; 
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("AddOperationTermList",4, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 109: // AddOperationTermList ::= AddOperationTermList AddOperation NT$4 Term 
            {
              Obj RESULT =null;
              // propagate RESULT from NT$4
                RESULT = (Obj) ((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).value;
		int tip1left = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-3)).left;
		int tip1right = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-3)).right;
		Obj tip1 = (Obj)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-3)).value;
		int operationleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)).left;
		int operationright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)).right;
		Integer operation = (Integer)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)).value;
		int tip2left = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).left;
		int tip2right = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).right;
		Obj tip2 = (Obj)((java_cup.runtime.Symbol) CUP$MJParser$stack.peek()).value;
		
							if((tip1.getType() != Tab.find("int").getType()) || (tip2.getType() != Tab.find("int").getType()))
							{ 
								parser.report_error("Greska na liniji " + tip1left + " aritmetika mora sa int!", null); 
								messages[messagesCnt++] = "Greska na liniji " + tip1left + " aritmetika mora sa int!";
							}
							
							if(!combArithOp)
							{
								Code.put(operation);
							}
							else
							{	
								combArithOp = false;
							}
							
						 	RESULT = tip2;
						 
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("AddOperationTermList",4, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-3)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 108: // NT$4 ::= 
            {
              Obj RESULT =null;
		int tip1left = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).left;
		int tip1right = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).right;
		Obj tip1 = (Obj)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).value;
		int operationleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).left;
		int operationright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).right;
		Integer operation = (Integer)((java_cup.runtime.Symbol) CUP$MJParser$stack.peek()).value;

							if(combArithOp)
							{
								combArithOpDesignator[combArithOpCnt-1] = tip1;
								combArithOpArray[combArithOpCnt-1] = operation;
								
							}
						 
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("NT$4",73, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 107: // ExpressionSign ::= 
            {
              Object RESULT =null;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("ExpressionSign",27, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 106: // ExpressionSign ::= MINUS 
            {
              Object RESULT =null;
		 minusExists = true; 
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("ExpressionSign",27, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 105: // Expression ::= ExpressionSign AddOperationTermList 
            {
              Obj RESULT =null;
		int tleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).left;
		int tright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).right;
		Obj t = (Obj)((java_cup.runtime.Symbol) CUP$MJParser$stack.peek()).value;
		 
					RESULT = t;

					if(minusExists)
					{
					if(t.getType() != Tab.find("int").getType()) 
					{ 
						parser.report_error("Greska na liniji " + tleft + " izraz sa minusom mora da bude int!", null); 
						messages[messagesCnt++] = "Greska na liniji " + tleft + " izraz sa minusom mora da bude int!";
					}
					
					Code.put(Code.neg);
					minusExists = false;
					}
 
				
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Expression",25, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 104: // ConditionFactRelationOperationExpression ::= 
            {
              Object RESULT =null;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("ConditionFactRelationOperationExpression",14, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 103: // ConditionFactRelationOperationExpression ::= RelationOperation Expression 
            {
              Object RESULT =null;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("ConditionFactRelationOperationExpression",14, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 102: // ConditionFact ::= Expression ConditionFactRelationOperationExpression 
            {
              Object RESULT =null;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("ConditionFact",13, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 101: // AndConditionFactList ::= 
            {
              Object RESULT =null;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("AndConditionFactList",5, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 100: // AndConditionFactList ::= AndConditionFactList AND ConditionFact 
            {
              Object RESULT =null;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("AndConditionFactList",5, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 99: // ConditionTerm ::= ConditionFact AndConditionFactList 
            {
              Object RESULT =null;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("ConditionTerm",15, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 98: // OrConditionTermList ::= 
            {
              Object RESULT =null;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("OrConditionTermList",48, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 97: // OrConditionTermList ::= OrConditionTermList OR ConditionTerm 
            {
              Object RESULT =null;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("OrConditionTermList",48, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 96: // Condition ::= ConditionTerm OrConditionTermList 
            {
              Object RESULT =null;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Condition",12, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 95: // ExpressionList ::= Expression 
            {
              Object RESULT =null;
		int eleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).left;
		int eright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).right;
		Obj e = (Obj)((java_cup.runtime.Symbol) CUP$MJParser$stack.peek()).value;
		 
				   		niz[cnt++] = e; 
				   		parser.report_info("Pronadjeno koriscenje stvarnog parametra " + e.getName() + " na liniji " + eleft, null);
						messages[messagesCnt++] = "Pronadjeno koriscenje stvarnog parametra " + e.getName() + " na liniji " + eleft;
				   
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("ExpressionList",26, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 94: // ExpressionList ::= ExpressionList COMA Expression 
            {
              Object RESULT =null;
		int eleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).left;
		int eright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).right;
		Obj e = (Obj)((java_cup.runtime.Symbol) CUP$MJParser$stack.peek()).value;
		
				   		niz[cnt++] = e; 
				   		parser.report_info("Pronadjeno koriscenje stvarnog parametra " + e.getName() + " vrednosti " + e.getAdr() + " na liniji " + eleft, null);
				   		messages[messagesCnt++] = "Pronadjeno koriscenje stvarnog parametra " + e.getName() + " vrednosti " + e.getAdr() + " na liniji " + eleft;
				   
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("ExpressionList",26, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 93: // ActualParameters ::= ExpressionList 
            {
              Object RESULT =null;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("ActualParameters",0, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 92: // DesignatorStatementActualParameters ::= 
            {
              Object RESULT =null;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("DesignatorStatementActualParameters",23, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 91: // DesignatorStatementActualParameters ::= ActualParameters 
            {
              Object RESULT =null;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("DesignatorStatementActualParameters",23, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 90: // DesignatorStatement ::= Designator EQUAL error 
            {
              Object RESULT =null;
		int eleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).left;
		int eright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).right;
		Object e = (Object)((java_cup.runtime.Symbol) CUP$MJParser$stack.peek()).value;
		
							parser.log.debug("Oporavak od greske prilikom dodele vrednosti na liniji " + eleft + " !");
							messages[messagesCnt++] = "Oporavak od greske prilikom dodele vrednosti na liniji " + eleft + " !";
						
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("DesignatorStatement",22, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 89: // DesignatorStatement ::= Designator DECREMENT 
            {
              Object RESULT =null;
		int dleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).left;
		int dright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).right;
		Obj d = (Obj)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).value;
		
							if(d.getKind() != Obj.Var)
							{ 
								parser.report_error("Greska na liniji " + dleft + " dekrementirati se moze jedino promenljiva!", null); 
								messages[messagesCnt++] = "Greska na liniji " + dleft + " dekrementirati se moze jedino promenljiva!";
							}
							if(d.getType() != Tab.find("int").getType()) 
							{ 
								parser.report_error("Greska na liniji " + dleft + " dekrementirati se moze jedino int!", null);
								messages[messagesCnt++] = "Greska na liniji " + dleft + " dekrementirati se moze jedino int!";
							}
						
							Code.load(d);
							Code.put(Code.const_1);
							Code.put(Code.sub);
							Code.store(d);
						
						
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("DesignatorStatement",22, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 88: // DesignatorStatement ::= Designator INCREMENT 
            {
              Object RESULT =null;
		int dleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).left;
		int dright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).right;
		Obj d = (Obj)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).value;
		
							if(d.getKind() != Obj.Var)
							{ 
								parser.report_error("Greska na liniji " + dleft + " inkrementirati se moze jedino promenljiva!", null); 
								messages[messagesCnt++] = "Greska na liniji " + dleft + " inkrementirati se moze jedino promenljiva!";
							}
							if(d.getType() != Tab.find("int").getType()) 
							{ 
								parser.report_error("Greska na liniji " + dleft + " inkrementirati se moze jedino int!", null);
								messages[messagesCnt++] = "Greska na liniji " + dleft + " inkrementirati se moze jedino int!";
							}
						
							Code.load(d);
							Code.put(Code.const_1);
							Code.put(Code.add);
							Code.store(d);
						
						
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("DesignatorStatement",22, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 87: // DesignatorStatement ::= Designator LPAREN DesignatorStatementActualParameters RPAREN 
            {
              Object RESULT =null;
		int dleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-3)).left;
		int dright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-3)).right;
		Obj d = (Obj)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-3)).value;
		
							if(d.getKind() != Obj.Meth)
							{ 
								parser.report_error("Greska na liniji " + dleft + " neterminal mora biti metoda!", null); 
								messages[messagesCnt++] = "Greska na liniji " + dleft + " neterminal mora biti metoda!";
							}
							
							int paramCnt = d.getLevel();
							
							if(paramCnt != cnt)
							{ 
								parser.report_error("Greska na liniji " + dleft + " poziv funkcije nema dovoljan broj parametara! Ima ih " + cnt + ", a treba da ih bude " + paramCnt + "!" , null);
								messages[messagesCnt++] = "Greska na liniji " + dleft + " poziv funkcije nema dovoljan broj parametara! Ima ih " + cnt + ", a treba da ih bude " + paramCnt + "!";
							}
							
							int tek = 0;
							
							for(Obj param : d.getLocalSymbols()) 
							{	
					   			if(tek >= cnt) { break; }
					   			
					   			if(niz[tek++].getType().getKind() != param.getType().getKind()) 
					   			{ 
									parser.report_error("Greska na liniji " + dleft + " parametar na poziciji " + tek + " nije odgovarajuceg tipa!", null); 
									messages[messagesCnt++] = "Greska na liniji " + dleft + " parametar na poziciji " + tek + " nije odgovarajuceg tipa!";
								}
							}
							
							cnt = 0;
							
							int destAdr = d.getAdr() - Code.pc;
							Code.put(Code.call);
							Code.put2(destAdr);
							if (d.getType() != Tab.noType)
							Code.put(Code.pop);
							
						
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("DesignatorStatement",22, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-3)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 86: // DesignatorStatement ::= Designator AssignOperation NT$3 Expression 
            {
              Object RESULT =null;
              // propagate RESULT from NT$3
                RESULT = (Object) ((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).value;
		int dleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-3)).left;
		int dright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-3)).right;
		Obj d = (Obj)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-3)).value;
		int operationleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)).left;
		int operationright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)).right;
		Integer operation = (Integer)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)).value;
		int eleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).left;
		int eright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).right;
		Obj e = (Obj)((java_cup.runtime.Symbol) CUP$MJParser$stack.peek()).value;
		
							if(d.getKind() != Obj.Var && d.getKind() != Obj.Elem)
							{ 
								parser.report_error("Greska na liniji " + eleft + " leva strana mora biti promenljiva!", null); 
								messages[messagesCnt++] = "Greska na liniji " + eleft + " leva strana mora biti promenljiva!";
							}
							
							
							if(newArray || isArray)
							{
								
								/*
								if(d.getType() != null)
								{
									if(!d.getType().compatibleWith(e.getType()))
									{
										parser.report_error("Greska na liniji " + eleft + " izraz nije kompatibalan sa neterminalom na levoj strani (nizovi)!", null);
										messages[messagesCnt++] = "Greska na liniji " + eleft + " izraz nije kompatibalan sa neterminalom na levoj strani (nizovi)!";
									}
								}
								*/
								
								
								if((d.getType() == Tab.intType) && (e.getType() != Tab.intType))
								{
									parser.report_error("Greska na liniji " + eleft + " izraz nije kompatibalan sa neterminalom na levoj strani (int)!", null);
									messages[messagesCnt++] = "Greska na liniji " + eleft + " izraz nije kompatibalan sa neterminalom na levoj strani (int)!";
								}
								
								if((d.getType() == Tab.charType) && (e.getType() != Tab.charType))
								{
									parser.report_error("Greska na liniji " + eleft + " izraz nije kompatibalan sa neterminalom na levoj strani (char)!", null);
									messages[messagesCnt++] = "Greska na liniji " + eleft + " izraz nije kompatibalan sa neterminalom na levoj strani (char)!";
								}
								
								if((d.getType() == Tab.find("bool").getType()) && (e.getType() != Tab.find("bool").getType()))
								{
									parser.report_error("Greska na liniji " + eleft + " izraz nije kompatibalan sa neterminalom na levoj strani (bool)!", null);
									messages[messagesCnt++] = "Greska na liniji " + eleft + " izraz nije kompatibalan sa neterminalom na levoj strani (bool)!";
								}
								
								/*
								if(combArithOpCnt>0)
								{
									Code.put(operation);
								}
								
								combArithOpCnt = 0;
								newArray = false;
								isArray = false;
								*/
							}
							else
							{
								if(!d.getType().compatibleWith(e.getType()))
								{	 
									parser.report_error("Greska na liniji " + eleft + " izraz nije kompatibalan sa neterminalom na levoj strani!", null);
									messages[messagesCnt++] = "Greska na liniji " + eleft + " izraz nije kompatibalan sa neterminalom na levoj strani!";								
								}
							}
							
						
							parser.report_info("ZAVRSIO SAM IZRAZ I CNT JE " + combArithOpCnt + "!!!", null);
						
							if(combArithOpCnt>0)
							{	
								if(d.getKind() == Obj.Elem)
								{
									if(d.getType() != Tab.find("int").getType())
									{ 
										parser.report_error("Greska na liniji " + eleft + " mora biti tipa int i leva strana mora biti promenljiva tipa int!", null);
										messages[messagesCnt++] = "Greska na liniji " + eleft + " mora biti tipa int i leva strana mora biti promenljiva tipa int!";
									}
								}
								else
								{
									if((d.getType() != Tab.find("int").getType()) || 
										(e.getType() != Tab.find("int").getType()) ||
										(d.getKind() != Obj.Var))
										{ 
											parser.report_error("Greska na liniji " + eleft + " mora biti tipa int i leva strana mora biti promenljiva!", null);
											messages[messagesCnt++] = "Greska na liniji " + eleft + " mora biti tipa int i leva strana mora biti promenljiva!";
										}
								}
								
								Obj temp = new Obj(Obj.Var, "", Tab.intType);
								
								while(combArithOpCnt>0)
								{
									combArithOpCnt--;
									
									if(combArithOpCnt>0)
									{
										if(combArithOpDesignator[combArithOpCnt].getKind() != Obj.Elem)
										{
											Code.put(combArithOpArray[combArithOpCnt]);
											Code.store(combArithOpDesignator[combArithOpCnt]);
											Code.load(combArithOpDesignator[combArithOpCnt]);
										}
										else
										{
											Code.put(combArithOpArray[combArithOpCnt]);
								
											Code.store(temp);
											
											Obj c = topScope.findSymbol(combArithOpDesignator[combArithOpCnt].getName());
											Code.load(c);
											Code.loadConst(combArithOpDesignator[combArithOpCnt].getFpPos());
											
											Code.load(temp);
											
											Code.store(combArithOpDesignator[combArithOpCnt]);
											Code.load(c);
											Code.loadConst(combArithOpDesignator[combArithOpCnt].getFpPos());
											Code.load(combArithOpDesignator[combArithOpCnt]);
										}
									}
									else
									{
										if(combArithOpDesignator[combArithOpCnt].getKind() != Obj.Elem)
										{
											Code.put(combArithOpArray[combArithOpCnt]);
										}
										else
										{
											Code.put(combArithOpArray[combArithOpCnt]);
								
											Code.store(temp);
											
											Obj c = topScope.findSymbol(combArithOpDesignator[combArithOpCnt].getName());
											Code.load(c);
											Code.loadConst(combArithOpDesignator[combArithOpCnt].getFpPos());
											
											Code.load(temp);
										}
										
									}
								}
							}
							
							Code.store(d);
							
							combArithOpCnt = 0;
							combArithOp = false;
							
						
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("DesignatorStatement",22, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-3)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 85: // NT$3 ::= 
            {
              Object RESULT =null;
		int dleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).left;
		int dright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).right;
		Obj d = (Obj)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).value;
		int operationleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).left;
		int operationright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).right;
		Integer operation = (Integer)((java_cup.runtime.Symbol) CUP$MJParser$stack.peek()).value;

							if(combArithOp)
							{
								/*
								if(d.getKind() == Obj.Elem)
								{
									Code.load(Tab.find(d.getName()));
									Code.loadConst(d.getAdr());
								}
								*/
								
								Code.load(d);
								combArithOpDesignator[combArithOpCnt-1] = d;
								combArithOp = false;
							}
						
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("NT$3",72, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 84: // PrintNumConst ::= 
            {
              Integer RESULT =null;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("PrintNumConst",49, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 83: // PrintNumConst ::= COMA NUMBER 
            {
              Integer RESULT =null;
		int valueleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).left;
		int valueright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).right;
		Integer value = (Integer)((java_cup.runtime.Symbol) CUP$MJParser$stack.peek()).value;
		
						isPrintNumConst = true;
						RESULT = value;
				  
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("PrintNumConst",49, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 82: // ForCondition ::= 
            {
              Object RESULT =null;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("ForCondition",31, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 81: // ForCondition ::= Condition 
            {
              Object RESULT =null;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("ForCondition",31, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 80: // ForDesignatorStatement ::= 
            {
              Object RESULT =null;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("ForDesignatorStatement",32, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 79: // ForDesignatorStatement ::= DesignatorStatement 
            {
              Object RESULT =null;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("ForDesignatorStatement",32, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 78: // Matched ::= LBRACE StatementList RBRACE 
            {
              Object RESULT =null;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Matched",36, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 77: // Matched ::= PRINT LPAREN Expression PrintNumConst RPAREN SEMI 
            {
              Object RESULT =null;
		int eleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-3)).left;
		int eright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-3)).right;
		Obj e = (Obj)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-3)).value;
		int valueleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)).left;
		int valueright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)).right;
		Integer value = (Integer)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)).value;
		
				if((e.getType() != Tab.find("int").getType()) && 
				   (e.getType() != Tab.find("char").getType()) &&
				   (e.getType() != Tab.find("bool").getType()))
				{ 
					parser.report_error("Greska na liniji " + eleft + " parametar mora biti int, char ili bool!", null); 
					messages[messagesCnt++] = "Greska na liniji " + eleft + " parametar mora biti int, char ili bool!";
				}
				
				if (e.getType() == Tab.find("int").getType()) 
				{
			  	 	if(isPrintNumConst)
					{
						Code.loadConst(value);
						isPrintNumConst = false;
					}
					else
					{
						Code.loadConst(5);
					}
			  	 	
					Code.put(Code.print);
			  	 }
			  	 
			  	 if (e.getType() == Tab.find("char").getType()) 
				 {
					if(isPrintNumConst)
					{
						Code.loadConst(value);
						isPrintNumConst = false;
					}
					else
					{
						Code.loadConst(1);
					}
			  	 	
					Code.put(Code.bprint);
			  	 }
				
				if (e.getType() == Tab.find("bool").getType()) 
				{
			  	 	if(isPrintNumConst)
					{
						Code.loadConst(value);
						isPrintNumConst = false;
					}
					else
					{
						Code.loadConst(5);
					}
			  	 	
					Code.put(Code.print);
			  	 }
				
			
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Matched",36, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-5)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 76: // Matched ::= READ LPAREN Designator RPAREN SEMI 
            {
              Object RESULT =null;
		int dleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)).left;
		int dright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)).right;
		Obj d = (Obj)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)).value;
		
				if(d.getKind() != Obj.Var)
				{ 
					parser.report_error("Greska na liniji " + dleft + " parametar mora biti promenljiva!", null); 
					messages[messagesCnt++] = "Greska na liniji " + dleft + " parametar mora biti promenljiva!";
				}
				
				if((d.getType() != Tab.find("int").getType()) && 
				   (d.getType() != Tab.find("char").getType()) &&
				   (d.getType() != Tab.find("bool").getType()))
				{ 
					parser.report_error("Greska na liniji " + dleft + " parametar mora biti int, char ili bool!", null); 
					messages[messagesCnt++] = "Greska na liniji " + dleft + " parametar mora biti int, char ili bool!";
				}
				
				Code.put(Code.read);
                Code.store(d);
				
			
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Matched",36, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-4)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 75: // Matched ::= RETURN SEMI 
            {
              Object RESULT =null;
		
				returnFound = true;
				if(!methIsVoid)
				{ 
					parser.report_error("Greska, ne moze funkcija koja nije void da ima return bez izraza!", null); 
					messages[messagesCnt++] = "Greska, ne moze funkcija koja nije void da ima return bez izraza!";
				}
			
				Code.put(Code.exit);
				Code.put(Code.return_);
			
			
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Matched",36, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 74: // Matched ::= RETURN Expression SEMI 
            {
              Object RESULT =null;
		int eleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).left;
		int eright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).right;
		Obj e = (Obj)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).value;
		
				returnFound = true;
				if (!currentMethodReturnType.compatibleWith(e.getType())) 
				{ 
					parser.report_error("Greska na liniji " + eleft + " : " + "tip izraza u return naredbi ne slaze se sa tipom povratne vrednosti funkcije!", null); 
					messages[messagesCnt++] = "Greska na liniji " + eleft + " : " + "tip izraza u return naredbi ne slaze se sa tipom povratne vrednosti funkcije!";
				}
			
				Code.put(Code.exit);
				Code.put(Code.return_);
				
			
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Matched",36, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 73: // Matched ::= CONTINUE SEMI 
            {
              Object RESULT =null;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Matched",36, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 72: // Matched ::= BREAK SEMI 
            {
              Object RESULT =null;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Matched",36, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 71: // Matched ::= DesignatorStatement SEMI 
            {
              Object RESULT =null;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Matched",36, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 70: // Matched ::= FOR LPAREN ForDesignatorStatement SEMI ForCondition SEMI ForDesignatorStatement RPAREN Matched 
            {
              Object RESULT =null;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Matched",36, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-8)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 69: // Matched ::= IF LPAREN Condition RPAREN Matched ELSE Matched 
            {
              Object RESULT =null;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Matched",36, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-6)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 68: // Unmatched ::= FOR LPAREN ForDesignatorStatement SEMI ForCondition SEMI ForDesignatorStatement RPAREN Unmatched 
            {
              Object RESULT =null;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Unmatched",59, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-8)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 67: // Unmatched ::= IF LPAREN Condition RPAREN Matched ELSE Unmatched 
            {
              Object RESULT =null;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Unmatched",59, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-6)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 66: // Unmatched ::= IF LPAREN Condition RPAREN Statement 
            {
              Object RESULT =null;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Unmatched",59, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-4)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 65: // Statement ::= Matched 
            {
              Object RESULT =null;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Statement",54, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 64: // Statement ::= Unmatched 
            {
              Object RESULT =null;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Statement",54, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 63: // Type ::= IDENT 
            {
              Struct RESULT =null;
		int typeNameleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).left;
		int typeNameright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).right;
		String typeName = (String)((java_cup.runtime.Symbol) CUP$MJParser$stack.peek()).value;
		
	Obj typeNode = Tab.find(typeName);
	if (typeNode == Tab.noObj) 
	{
		parser.report_error("Greska na liniji " + typeNameleft + ": Nije pronadjen tip " + typeName + " u tabeli simbola", null);
		messages[messagesCnt++] = "Greska na liniji " + typeNameleft + ": Nije pronadjen tip " + typeName + " u tabeli simbola";
		RESULT = Tab.noType;
	}
	else 
	{
		if (Obj.Type == typeNode.getKind()) 
		{
			RESULT = typeNode.getType();
			currentVarType = RESULT;
			currentMethType = RESULT;
		}
		else 
		{
			parser.report_error("Greska na liniji" + typeNameleft+ ": Ime " + typeName + " ne predstavlja tip ", null);
			messages[messagesCnt++] = "Greska na liniji" + typeNameleft+ ": Ime " + typeName + " ne predstavlja tip ";
			RESULT = Tab.noType;
		}
	}

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Type",58, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 62: // VarArgs ::= Type DOT DOT DOT IDENT 
            {
              Object RESULT =null;
		int nameleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).left;
		int nameright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).right;
		String name = (String)((java_cup.runtime.Symbol) CUP$MJParser$stack.peek()).value;
		 varArgsName = name; 
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("VarArgs",60, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-4)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 61: // FormalParameterDeclaration ::= VarArgs 
            {
              Object RESULT =null;
		int valeft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).left;
		int varight = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).right;
		Object va = (Object)((java_cup.runtime.Symbol) CUP$MJParser$stack.peek()).value;
		
							   		if(varArgsExists) 
									{ 
										parser.report_error("Greska na liniji " + valeft + ", VarArgs naveden vise puta!", null); 
										messages[messagesCnt++] = "Greska na liniji " + valeft + ", VarArgs naveden vise puta!";
									}
							   		
							   		varArgsExists = true;
							   		
							   		Obj temp = Tab.currentScope().findSymbol(varArgsName);
					  				if(temp == null)
					  				{
										Obj o = Tab.insert(Obj.Var, varArgsName, currentVarType );
					  					o.setAdr(scopeOffset++);
					  					o.setFpPos(cntParam++);
					  					varArgsPosition = cntParam - 1;
					  					parser.report_info("Metoda ima parametar (VarArgs) " + varArgsName + ", naveden u liniji " + valeft , null);
										messages[messagesCnt++] = "Metoda ima parametar (VarArgs) " + varArgsName + ", naveden u liniji " + valeft;
					  				}
									else 
									{ 
										parser.report_error("Greska na liniji " + valeft + ", parametar istog imena vec postoji!", null);
										messages[messagesCnt++] = "Greska na liniji " + valeft + ", parametar istog imena vec postoji!";
									}
							   
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("FormalParameterDeclaration",33, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 60: // FormalParameterDeclaration ::= Type IDENT LSQUARE RSQUARE 
            {
              Object RESULT =null;
		int arrayNameleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)).left;
		int arrayNameright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)).right;
		String arrayName = (String)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)).value;
		
							   		Obj temp = Tab.currentScope().findSymbol(arrayName);
					  				if(temp == null)
					  				{
										Obj o = Tab.insert(Obj.Var, arrayName, new Struct(Struct.Array, currentVarType));
					  					o.setAdr(scopeOffset++);
					  					o.setFpPos(cntParam++);
					  					parser.report_info("Metoda ima parametar (niz) " + arrayName + ", naveden u liniji " + arrayNameleft , null);
										messages[messagesCnt++] = "Metoda ima parametar (niz) " + arrayName + ", naveden u liniji " + arrayNameleft;
					  				}
									else 
									{ 
										parser.report_error("Greska na liniji " + arrayNameleft + ", parametar istog imena vec postoji!", null); 
										messages[messagesCnt++] = "Greska na liniji " + arrayNameleft + ", parametar istog imena vec postoji!";
									}
							   
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("FormalParameterDeclaration",33, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-3)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 59: // FormalParameterDeclaration ::= Type IDENT 
            {
              Object RESULT =null;
		int varNameleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).left;
		int varNameright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).right;
		String varName = (String)((java_cup.runtime.Symbol) CUP$MJParser$stack.peek()).value;
		
									Obj temp = Tab.currentScope().findSymbol(varName);
					  				if(temp == null)
					  				{
										Obj o = Tab.insert(Obj.Var, varName, currentVarType );
					  					o.setAdr(scopeOffset++);
					  					o.setFpPos(cntParam++);
					  					parser.report_info("Metoda ima parametar " + varName + ", naveden u liniji " + varNameleft , null);
										messages[messagesCnt++] = "Metoda ima parametar " + varName + ", naveden u liniji " + varNameleft;
					  				}
									else 
									{ 
										parser.report_error("Greska na liniji " + varNameleft + ", parametar istog imena vec postoji!", null); 
										messages[messagesCnt++] = "Greska na liniji " + varNameleft + ", parametar istog imena vec postoji!";
									}
								
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("FormalParameterDeclaration",33, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 58: // FormalParameterList ::= FormalParameterDeclaration 
            {
              Object RESULT =null;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("FormalParameterList",34, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 57: // FormalParameterList ::= FormalParameterList COMA FormalParameterDeclaration 
            {
              Object RESULT =null;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("FormalParameterList",34, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 56: // FormalParameters ::= 
            {
              Object RESULT =null;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("FormalParameters",35, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 55: // FormalParameters ::= FormalParameterList 
            {
              Object RESULT =null;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("FormalParameters",35, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 54: // Static ::= 
            {
              Object RESULT =null;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Static",56, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 53: // Static ::= STATIC 
            {
              Object RESULT =null;
		
		   		staticExists = true;
		   
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Static",56, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 52: // StatementList ::= 
            {
              Object RESULT =null;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("StatementList",55, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 51: // StatementList ::= StatementList Statement 
            {
              Object RESULT =null;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("StatementList",55, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 50: // MethodVarDeclarationList ::= 
            {
              Object RESULT =null;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("MethodVarDeclarationList",40, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 49: // MethodVarDeclarationList ::= MethodVarDeclarationList VarDeclaration 
            {
              Object RESULT =null;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("MethodVarDeclarationList",40, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 48: // MethodDeclarationList ::= 
            {
              Object RESULT =null;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("MethodDeclarationList",38, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 47: // MethodDeclarationList ::= MethodDeclarationList MethodDeclaration 
            {
              Object RESULT =null;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("MethodDeclarationList",38, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 46: // ReturnType ::= VOID 
            {
              Object RESULT =null;
		
			   		currentMethodReturnType = Tab.noType;
			   		methIsVoid = true;
			   
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("ReturnType",53, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 45: // ReturnType ::= Type 
            {
              Object RESULT =null;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("ReturnType",53, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 44: // MethodName ::= IDENT 
            {
              Object RESULT =null;
		int methNameleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).left;
		int methNameright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).right;
		String methName = (String)((java_cup.runtime.Symbol) CUP$MJParser$stack.peek()).value;
		
					inMethod = true;

					if(staticExists && !parser.inClass)
					{ 
						parser.report_error("Greska na liniji " + methNameleft + ", ne moze globalna metoda biti static!", null); 
						messages[messagesCnt++] = "Greska na liniji " + methNameleft + ", ne moze globalna metoda biti static!";
					}
	
					staticExists = false;

					if(methName.equals("main") && !parser.inClass) 
					{ 
						parser.inMain = true;
						mainExists = true; 
		
						if(currentMethodReturnType == Tab.noType) { mainIsVoid = true; }
						else 
						{ 
							parser.report_error("Greska na liniji " + methNameleft + ", main mora biti tipa void", null); 
							messages[messagesCnt++] = "Greska na liniji " + methNameleft + ", main mora biti tipa void";
						}
					}
					else { parser.inMain = false; }
	
					currentMethod = Tab.insert(Obj.Meth, methName, currentMethType);
					currentMethodReturnType = currentMethType;
					Tab.openScope();
					parser.report_info("Definisana metoda " + methName + " na liniji " + methNameleft, null);
					messages[messagesCnt++] = "Definisana metoda " + methName + " na liniji " + methNameleft;
	
					stack.push(scopeOffset);
					scopeOffset = 0;
				
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("MethodName",39, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 43: // MethodDeclaration ::= Static ReturnType MethodName LPAREN FormalParameters RPAREN MethodVarDeclarationList LBRACE NT$2 StatementList RBRACE 
            {
              Object RESULT =null;
              // propagate RESULT from NT$2
                RESULT = (Object) ((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)).value;
		 
							if((parser.inMain) && (cntParam > 0)) 
							{ 
								parser.report_error("Greska, main ne sme imati parametre!", null);
								messages[messagesCnt++] = "Greska, main ne sme imati parametre!";
							}

							parser.inMain = false;
							inMethod = false;
	
							Code.put(Code.exit);
							Code.put(Code.return_);
							
							Tab.chainLocalSymbols(currentMethod);
							Tab.closeScope();
							currentMethod = null;
	
							scopeOffset = (int) stack.pop();
	
							if((varArgsExists) && (varArgsPosition != cntParam - 1 )) 
							{ 
								parser.report_error("Greska, VarArgs mora da se navede na kraju liste parametara!", null); 
								messages[messagesCnt++] = "Greska, VarArgs mora da se navede na kraju liste parametara!";
							}
	
							cntParam = 0;
							varArgsExists = false;
							varArgsPosition = -1;
	
							if((!methIsVoid) && (!returnFound))
							{ 
								parser.report_error("Greska, funkcija koja nije void mora da ima return!", null); 
								messages[messagesCnt++] = "Greska, funkcija koja nije void mora da ima return!";
							}
	
							returnFound = false;
							methIsVoid = false;
						
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("MethodDeclaration",37, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-10)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 42: // NT$2 ::= 
            {
              Object RESULT =null;

							currentMethod.setAdr(Code.pc);
							
							if (parser.inMain) 
							{
								Code.mainPc = currentMethod.getAdr();
							}
							
							currentMethod.setLevel(cntParam);
							
							Code.put(Code.enter);
							Code.put(currentMethod.getLevel());
							Code.put(Tab.currentScope().getnVars());
					  
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("NT$2",71, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 41: // _ClassEnd ::= 
            {
              Object RESULT =null;
		 parser.inClass = false; 
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("_ClassEnd",65, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 40: // _ClassBegin ::= 
            {
              Object RESULT =null;
		 parser.inClass = true; 
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("_ClassBegin",64, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 39: // ClassMethodDeclaration ::= 
            {
              Object RESULT =null;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("ClassMethodDeclaration",8, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 38: // ClassMethodDeclaration ::= LBRACE MethodDeclarationList RBRACE 
            {
              Object RESULT =null;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("ClassMethodDeclaration",8, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 37: // ClassVarDeclarationList ::= 
            {
              Object RESULT =null;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("ClassVarDeclarationList",11, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 36: // ClassVarDeclarationList ::= ClassVarDeclarationList ClassVarDeclaration 
            {
              Object RESULT =null;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("ClassVarDeclarationList",11, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 35: // ExtendType ::= 
            {
              Object RESULT =null;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("ExtendType",28, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 34: // ExtendType ::= EXTENDS Type 
            {
              Object RESULT =null;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("ExtendType",28, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 33: // ClassName ::= IDENT 
            {
              Object RESULT =null;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("ClassName",9, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 32: // ClassDeclaration ::= CLASS ClassName ExtendType _ClassBegin LBRACE ClassVarDeclarationList ClassMethodDeclaration _ClassEnd RBRACE 
            {
              Object RESULT =null;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("ClassDeclaration",7, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-8)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 31: // _CountVar ::= 
            {
              Object RESULT =null;
		 
	if(parser.globalVarDecl && !parser.inClass) { parser.countGlobalVar++; }
	if(parser.inMain && !parser.inClass) { parser.countLocalVar++; } 

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("_CountVar",66, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 30: // VarError ::= COMA error 
            {
              Object RESULT =null;
		int eleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).left;
		int eright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).right;
		Object e = (Object)((java_cup.runtime.Symbol) CUP$MJParser$stack.peek()).value;
		
			 	parser.log.debug("Oporavak od greske prilikom deklarisanja promenljive na liniji " + eleft + " !");
				messages[messagesCnt++] = "Oporavak od greske prilikom deklarisanja promenljive na liniji " + eleft + " !";
			 
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("VarError",62, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 29: // VarError ::= error COMA 
            {
              Object RESULT =null;
		int eleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).left;
		int eright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).right;
		Object e = (Object)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).value;
		
			 	parser.log.debug("Oporavak od greske prilikom deklarisanja promenljive na liniji " + eleft + " !");
				messages[messagesCnt++] = "Oporavak od greske prilikom deklarisanja promenljive na liniji " + eleft + " !";
			 
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("VarError",62, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 28: // ClassVarDeclaration ::= Static Type VarList SEMI 
            {
              Object RESULT =null;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("ClassVarDeclaration",10, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-3)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 27: // OneVarDeclaration ::= IDENT LSQUARE RSQUARE _CountVar 
            {
              Object RESULT =null;
		int arrayNameleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-3)).left;
		int arrayNameright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-3)).right;
		String arrayName = (String)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-3)).value;
		
					  		Obj temp = Tab.currentScope().findSymbol(arrayName);
					  		if(temp == null)
					  		{
					  			Obj o = Tab.insert(Obj.Var, arrayName, new Struct(Struct.Array, currentVarType));
					  			o.setAdr(scopeOffset++);
					  			if(parser.globalVarDecl && !parser.inClass)
					  			{ 
									parser.report_info("Deklarisan globalni niz " + arrayName + " na liniji " + arrayNameleft , null); 
									messages[messagesCnt++] ="Deklarisan globalni niz " + arrayName + " na liniji " + arrayNameleft;
								}
					  			else if(!parser.inClass)
					  			{ 
									parser.report_info("Deklarisan lokalni niz " + arrayName + " na liniji " + arrayNameleft , null); 
									messages[messagesCnt++] ="Deklarisan lokalni niz " + arrayName + " na liniji " + arrayNameleft;
								}
					  		}
					  		else
					  		{ 
								parser.report_error("Greska na liniji " + arrayNameleft + " promenljiva sa imenom " + arrayName + " vec postoji u istom opsegu!", null); 
								messages[messagesCnt++] = "Greska na liniji " + arrayNameleft + " promenljiva sa imenom " + arrayName + " vec postoji u istom opsegu!";
							}
					  
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("OneVarDeclaration",47, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-3)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 26: // OneVarDeclaration ::= IDENT _CountVar 
            {
              Object RESULT =null;
		int varNameleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).left;
		int varNameright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).right;
		String varName = (String)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).value;
		
					  		Obj temp = Tab.currentScope().findSymbol(varName);
					  		if(temp == null)
					  		{
					  			Obj o = Tab.insert(Obj.Var, varName, currentVarType );
					  			o.setAdr(scopeOffset++);
					  			if(parser.globalVarDecl && !parser.inClass)
					  			{ 
									parser.report_info("Deklarisana globalna promenljiva " + varName + " na liniji " + varNameleft , null); 
									messages[messagesCnt++] ="Deklarisana globalna promenljiva " + varName + " na liniji " + varNameleft;
								}
					  			else if(!parser.inClass)
					  			{ 
									parser.report_info("Deklarisana lokalna promenljiva " + varName + " na liniji " + varNameleft , null); 
									messages[messagesCnt++] ="Deklarisana lokalna promenljiva " + varName + " na liniji " + varNameleft;
								}
					  		}
					  		else
					  		{ 
								parser.report_error("Greska na liniji " + varNameleft + " promenljiva sa imenom " + varName + " vec postoji u istom opsegu!", null); 
								messages[messagesCnt++] ="Greska na liniji " + varNameleft + " promenljiva sa imenom " + varName + " vec postoji u istom opsegu!";
							}
					  
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("OneVarDeclaration",47, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 25: // VarList ::= OneVarDeclaration 
            {
              Object RESULT =null;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("VarList",63, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 24: // VarList ::= VarList COMA OneVarDeclaration 
            {
              Object RESULT =null;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("VarList",63, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 23: // VarDeclaration ::= Type VarList VarError VarList SEMI 
            {
              Object RESULT =null;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("VarDeclaration",61, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-4)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 22: // VarDeclaration ::= Type VarList error SEMI NT$1 Type VarError VarList SEMI 
            {
              Object RESULT =null;
              // propagate RESULT from NT$1
                RESULT = (Object) ((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-4)).value;
		int eleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-6)).left;
		int eright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-6)).right;
		Object e = (Object)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-6)).value;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("VarDeclaration",61, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-8)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 21: // NT$1 ::= 
            {
              Object RESULT =null;
		int eleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).left;
		int eright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).right;
		Object e = (Object)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).value;

				   		parser.log.debug("Oporavak od greske prilikom deklarisanja promenljive na liniji " + eleft + " !");
						messages[messagesCnt++] ="Oporavak od greske prilikom deklarisanja promenljive na liniji " + eleft + " !";
				   
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("NT$1",70, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 20: // VarDeclaration ::= Type error SEMI 
            {
              Object RESULT =null;
		int eleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).left;
		int eright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).right;
		Object e = (Object)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).value;
		
				   		parser.log.debug("Oporavak od greske prilikom deklarisanja promenljive na liniji " + eleft + " !");
						messages[messagesCnt++] = "Oporavak od greske prilikom deklarisanja promenljive na liniji " + eleft + " !";
				   
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("VarDeclaration",61, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 19: // VarDeclaration ::= Type VarList SEMI 
            {
              Object RESULT =null;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("VarDeclaration",61, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 18: // ConstValue ::= NUMBER 
            {
              Object RESULT =null;
		int valueleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).left;
		int valueright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).right;
		Integer value = (Integer)((java_cup.runtime.Symbol) CUP$MJParser$stack.peek()).value;
		
			   		Obj provera = Tab.find("int");
			   		if(provera.getType() == currentConstType) { correctConstType = true; }
			   		else { correctConstType = false; }
			   		RESULT = value;
			   
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("ConstValue",18, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 17: // ConstValue ::= BOOL 
            {
              Object RESULT =null;
		int valueleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).left;
		int valueright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).right;
		String value = (String)((java_cup.runtime.Symbol) CUP$MJParser$stack.peek()).value;
		
			   		Obj provera = Tab.find("bool");
			   		if(provera.getType() == currentConstType) { correctConstType = true; }
			   		else { correctConstType = false; }
			   		if(value.equals("true")) { RESULT = 1; }
			   		else { RESULT = 0; }
			   
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("ConstValue",18, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 16: // ConstValue ::= CHAR 
            {
              Object RESULT =null;
		int valueleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).left;
		int valueright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).right;
		Character value = (Character)((java_cup.runtime.Symbol) CUP$MJParser$stack.peek()).value;
		
			   		Obj provera = Tab.find("char");
			   		if(provera.getType() == currentConstType) { correctConstType = true; }
			   		else { correctConstType = false; }
			   		RESULT = (int) value;
			   
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("ConstValue",18, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 15: // OneConstDeclaration ::= IDENT EQUAL error 
            {
              Object RESULT =null;
		int eleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).left;
		int eright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).right;
		Object e = (Object)((java_cup.runtime.Symbol) CUP$MJParser$stack.peek()).value;
		
							parser.log.debug("Oporavak od greske prilikom dodele vrednosti konstanti na liniji " + eleft + " !");
							messages[messagesCnt++] = "Oporavak od greske prilikom dodele vrednosti konstanti na liniji " + eleft + " !";
						
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("OneConstDeclaration",45, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 14: // OneConstDeclaration ::= IDENT EQUAL ConstValue 
            {
              Object RESULT =null;
		int constNameleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)).left;
		int constNameright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)).right;
		String constName = (String)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)).value;
		int valueleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).left;
		int valueright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).right;
		Object value = (Object)((java_cup.runtime.Symbol) CUP$MJParser$stack.peek()).value;
		
							if(parser.globalVarDecl && !parser.inClass) { parser.countGlobalConst++; }
							
							if(correctConstType)
							{
								Obj temp = Tab.currentScope().findSymbol(constName);
								if(temp == null)
								{
									Obj o = Tab.insert(Obj.Con, constName, currentConstType);
									o.setAdr((int) value);
									parser.report_info("Definisana je nova konstanta " + constName +" na liniji " + valueleft, null);
									messages[messagesCnt++] = "Definisana je nova konstanta " + constName +" na liniji " + valueleft;
								}
								else 
								{ 
									parser.report_error("Greska na liniji " + valueleft + " : Konstanta " + constName + " vec postoji! ", null);
									messages[messagesCnt++] = "Greska na liniji " + valueleft + " : Konstanta " + constName + " vec postoji! ";
								}
							}
							else 
							{ 
								parser.report_error("Greska na liniji " + valueleft + ": Konstanta " + constName + " nije odgovarajuceg tipa!", null); 
								messages[messagesCnt++] = "Greska na liniji " + valueleft + ": Konstanta " + constName + " nije odgovarajuceg tipa!";
							}
						
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("OneConstDeclaration",45, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 13: // ConstList ::= OneConstDeclaration 
            {
              Object RESULT =null;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("ConstList",17, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 12: // ConstList ::= ConstList COMA OneConstDeclaration 
            {
              Object RESULT =null;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("ConstList",17, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 11: // ConstDeclaration ::= CONST Type NT$0 ConstList SEMI 
            {
              Object RESULT =null;
              // propagate RESULT from NT$0
                RESULT = (Object) ((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)).value;
		int tleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-3)).left;
		int tright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-3)).right;
		Struct t = (Struct)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-3)).value;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("ConstDeclaration",16, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-4)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 10: // NT$0 ::= 
            {
              Object RESULT =null;
		int tleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).left;
		int tright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).right;
		Struct t = (Struct)((java_cup.runtime.Symbol) CUP$MJParser$stack.peek()).value;
 currentConstType = t; 
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("NT$0",69, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 9: // _ProgVarDeclEnd ::= 
            {
              Object RESULT =null;
		 parser.globalVarDecl = false; 
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("_ProgVarDeclEnd",68, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 8: // _ProgVarDeclBegin ::= 
            {
              Object RESULT =null;
		 parser.globalVarDecl = true; 
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("_ProgVarDeclBegin",67, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 7: // OneDeclaration ::= ClassDeclaration 
            {
              Object RESULT =null;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("OneDeclaration",46, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 6: // OneDeclaration ::= VarDeclaration 
            {
              Object RESULT =null;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("OneDeclaration",46, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 5: // OneDeclaration ::= ConstDeclaration 
            {
              Object RESULT =null;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("OneDeclaration",46, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 4: // DeclarationList ::= 
            {
              Object RESULT =null;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("DeclarationList",19, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 3: // DeclarationList ::= DeclarationList OneDeclaration 
            {
              Object RESULT =null;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("DeclarationList",19, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 2: // ProgramName ::= IDENT 
            {
              Obj RESULT =null;
		int programNameleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).left;
		int programNameright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).right;
		String programName = (String)((java_cup.runtime.Symbol) CUP$MJParser$stack.peek()).value;
		  
					RESULT = Tab.insert(Obj.Prog, programName, Tab.noType);
	
					//len funkcija
					Code.put(Code.enter);
					Code.put(1);
					Code.put(1);
					Code.put(Code.load_n);
					Code.put(Code.arraylength);
					Code.put(Code.exit);
					Code.put(Code.return_);
					Tab.lenObj.setAdr(0);
		
					// ord funkcija
					int addr = Code.pc;
					Code.put(Code.enter);
					Code.put(1);
					Code.put(1);
					Code.put(Code.load_n);
					Code.put(Code.exit);
					Code.put(Code.return_);
					Tab.ordObj.setAdr(addr);
		
					// chr funkcija
					addr = Code.pc;
					Code.put(Code.enter);
					Code.put(1);
					Code.put(1);
					Code.put(Code.load_n);
					Code.put(Code.exit);
					Code.put(Code.return_);
					Tab.chrObj.setAdr(addr);
	
					universeScope = Tab.currentScope;
					Tab.openScope();
					topScope = Tab.currentScope();
				
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("ProgramName",51, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 1: // $START ::= Program EOF 
            {
              Object RESULT =null;
		int start_valleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).left;
		int start_valright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).right;
		Object start_val = (Object)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).value;
		RESULT = start_val;
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("$START",0, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          /* ACCEPT */
          CUP$MJParser$parser.done_parsing();
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 0: // Program ::= PROG ProgramName _ProgVarDeclBegin DeclarationList _ProgVarDeclEnd LBRACE MethodDeclarationList RBRACE 
            {
              Object RESULT =null;
		int pleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-6)).left;
		int pright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-6)).right;
		Obj p = (Obj)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-6)).value;
		
				Code.dataSize = Tab.currentScope().getnVars();
	
				Tab.chainLocalSymbols(p);
				Tab.closeScope(); 
				
				parser.report_info("==================== SINTAKSNA ANALIZA ===================", null);
				parser.report_info("Broj globalnih konstanti = " + parser.countGlobalConst, null);
				parser.report_info("Broj globalnih promenljivih = " + parser.countGlobalVar, null);
				parser.report_info("Broj lokalnih promenljivih u main = " + parser.countLocalVar, null);
				
				parser.report_info("==================== SEMANTICKA ANALIZA ===================", null);
				int i=0;
				while(i<messagesCnt)
				{
					parser.report_info(messages[i++], null);
				}
				
				parser.report_info("===========================================================", null);
				
			
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Program",50, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-7)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /* . . . . . .*/
          default:
            throw new Exception(
               "Invalid action number found in internal parse table");

        }
    }
}

